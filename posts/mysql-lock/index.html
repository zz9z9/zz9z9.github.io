<!DOCTYPE html><html lang="en-US" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="MySQL - LOCK 살펴보기" /><meta property="og:locale" content="en_US" /><meta name="description" content="락을 잘 모르면 비효율적인 쿼리를 작성하거나, 데드락을 유발하거나, 불필요한 성능저하 등을 일으킬 수 있다고 생각한다. 또한 디버깅시 실마리를 못잡을 수도 있다. 이런 일을 최대한 겪지 않도록 MySQL에서는 어떤 락을 제공하는지 살펴보자." /><meta property="og:description" content="락을 잘 모르면 비효율적인 쿼리를 작성하거나, 데드락을 유발하거나, 불필요한 성능저하 등을 일으킬 수 있다고 생각한다. 또한 디버깅시 실마리를 못잡을 수도 있다. 이런 일을 최대한 겪지 않도록 MySQL에서는 어떤 락을 제공하는지 살펴보자." /><link rel="canonical" href="https://zz9z9.github.io/posts/mysql-lock/" /><meta property="og:url" content="https://zz9z9.github.io/posts/mysql-lock/" /><meta property="og:site_name" content="zz9z9" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-07-01T21:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MySQL - LOCK 살펴보기" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-07-14T23:21:11+09:00","datePublished":"2025-07-01T21:00:00+09:00","description":"락을 잘 모르면 비효율적인 쿼리를 작성하거나, 데드락을 유발하거나, 불필요한 성능저하 등을 일으킬 수 있다고 생각한다. 또한 디버깅시 실마리를 못잡을 수도 있다. 이런 일을 최대한 겪지 않도록 MySQL에서는 어떤 락을 제공하는지 살펴보자.","headline":"MySQL - LOCK 살펴보기","mainEntityOfPage":{"@type":"WebPage","@id":"https://zz9z9.github.io/posts/mysql-lock/"},"url":"https://zz9z9.github.io/posts/mysql-lock/"}</script><title>MySQL - LOCK 살펴보기 | zz9z9</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="zz9z9"><meta name="application-name" content="zz9z9"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-Q7PWLG5WYT"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Q7PWLG5WYT'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Soccerball.svg/1000px-Soccerball.svg.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">zz9z9</a></div><div class="site-subtitle font-italic">거창한 계획보다는, 꾸준한 실행을</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/zz9z9" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>MySQL - LOCK 살펴보기</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>MySQL - LOCK 살펴보기</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Lee JaeYoon </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Tue, Jul 1, 2025, 9:00 PM +0900" prep="on" > Jul 1, 2025 <i class="unloaded">2025-07-01T21:00:00+09:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Jul 14, 2025, 11:21 PM +0900" prefix="Updated " > Jul 14, 2025 <i class="unloaded">2025-07-14T23:21:11+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5139 words">28 min</span></div></div><div class="post-content"><blockquote><p>락을 잘 모르면 비효율적인 쿼리를 작성하거나, 데드락을 유발하거나, 불필요한 성능저하 등을 일으킬 수 있다고 생각한다. 또한 디버깅시 실마리를 못잡을 수도 있다. 이런 일을 최대한 겪지 않도록 MySQL에서는 어떤 락을 제공하는지 살펴보자.</p></blockquote><h2 id="lock-유형">Lock 유형</h2><hr /><blockquote><p>InnoDB는 <strong>행 수준(row-level) 잠금</strong>을 구현하며(테이블 수준 잠금도 지원), <strong>공유(S, Shared Lock) 잠금</strong>과 <strong>배타(X, Exclusive Lock) 잠금</strong> 두 가지 유형이 있다.</p></blockquote><h3 id="shared-lock">Shared Lock</h3><blockquote><p>공유(S) 잠금</p></blockquote><ul><li>해당 잠금을 보유한 트랜잭션이 행을 <strong>읽을 수 있도록 허용</strong><li>트랜잭션 T1이 행 r에 대해 공유(S) 잠금을 보유하고 있는 경우, 별개의 트랜잭션 T2가 행 r에 대해 잠금을 요청하면 다음과 같이 처리된다:<li>T2가 S 잠금을 요청한 경우, 즉시 허용한다.<ul><li><strong>그 결과, T1과 T2는 모두 r에 대해 S 잠금을 보유하게 된다.</strong></ul><li>T2가 X 잠금을 요청한 경우는 허용하지 않는다.</ul><h3 id="exclusive-lock">Exclusive Lock</h3><blockquote><p>배타(X) 잠금</p></blockquote><ul><li>해당 잠금을 보유한 트랜잭션이 행을 <strong>수정하거나 삭제할 수 있도록 허용</strong><li>트랜잭션 T1이 행 r에 대해 배타(X) 잠금을 보유하고 있는 경우, 별개의 트랜잭션 T2가 r에 대해 <strong>어떤 종류의 잠금(S 또는 X)을 요청하더라도 허용하지 않는다.</strong><li>즉, 트랜잭션 T2는 T1이 행 r에 대한 잠금을 해제할 때까지 기다려야 한다.</ul><h2 id="lock-종류">Lock 종류</h2><hr /><h3 id="intention-lock">Intention Lock</h3><blockquote><p>트랜잭션이 테이블의 <strong>특정 행</strong>에 대해 <strong>나중에 어떤 종류의 잠금(공유 또는 배타)을 설정할 것인지</strong>를 나타내는 <strong>테이블 수준의 잠금</strong></p></blockquote><p><strong>목적</strong></p><ul><li><strong>다중 세분화 잠금(multiple granularity locking)</strong>을 지원하여 행 잠금(row locks) 과 테이블 잠금(table locks) 이 <strong>공존하며 효율적으로 작동</strong>할 수 있게 하기 위함</ul><p><strong>예시를 통해 의도 잠금 필요성 이해하기</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>A 트랜잭션이 IX 락을 테이블에 걸고 있는 상태
B 트랜잭션이 LOCK TABLE my_table WRITE로 테이블 전체 락을 요청
→ IX 락이 이미 있기 때문에, 바로 충돌 판단 후 B는 block됨
→ 전체 행 잠금 목록을 다 뒤져볼 필요 없음
</pre></table></code></div></div><p>※ 다중 세분화 잠금(Multiple Granularity Locking) ?</p><ul><li>데이터베이스에서 여러 수준(granularity)의 객체에 대해 동시에 잠금을 설정할 수 있도록 하는 메커니즘<li>즉, 테이블(table), 페이지(page), 행(row)과 같이 데이터 구조의 다양한 수준에 대해 서로 다른 크기의 잠금을 동시에 적용할 수 있게 만드는 기법</ul><p><strong>종류</strong></p><ul><li>의도 공유 잠금(IS 잠금)<ul><li>트랜잭션이 테이블 내 개별 행들에 대해 공유 잠금을 설정하려고 의도하고 있음을 나타낸다.<li>ex : <code class="language-plaintext highlighter-rouge">SELECT ... FOR SHARE</code> 는 IS 잠금을 설정</ul><li>의도 배타 잠금(IX 잠금)<ul><li>트랜잭션이 테이블 내 개별 행들에 대해 배타 잠금을 설정하려고 의도하고 있음을 나타낸다.<li>ex : <code class="language-plaintext highlighter-rouge">SELECT ... FOR UPDATE</code>는 IX 잠금을 설정</ul></ul><p><strong>동작 방식</strong></p><ul><li>트랜잭션이 테이블의 <strong>행에 대해 공유 잠금을 획득하려면</strong>, 먼저 해당 테이블에 대해 IS 잠금 또는 그보다 강한 잠금을 획득해야 한다.<li>트랜잭션이 테이블의 <strong>행에 대해 배타 잠금을 획득하려면</strong>, 먼저 해당 테이블에 대해 IX 잠금을 획득해야 한다.<li>트랜잭션은 충돌하는 잠금이 해제될 때까지 대기한다.<li>하지만, 잠금 요청이 기존 잠금과 충돌하고 이로 인해 데드락(deadlock) 이 발생할 수 있다면, 에러가 발생한다.</ul><p><strong>잠금 호환성</strong></p><blockquote><p>의도 잠금은 <strong>전체 테이블 잠금 요청(예: LOCK TABLES … WRITE)</strong>을 제외하고는 아무것도 차단하지 않는다.</p></blockquote><div class="table-wrapper"><table><thead><tr><th>현재 잠금 ↓ / 요청 잠금 →<th><strong>X</strong><th><strong>IX</strong><th><strong>S</strong><th><strong>IS</strong><tbody><tr><td><strong>X</strong><td>❌<td>❌<td>❌<td>❌<tr><td><strong>IX</strong><td>❌<td>✅<td>❌<td>✅<tr><td><strong>S</strong><td>❌<td>❌<td>✅<td>✅<tr><td><strong>IS</strong><td>❌<td>✅<td>✅<td>✅</table></div><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>-- 트랜잭션 A
START TRANSACTION;
SELECT * FROM my_table WHERE id = 1 FOR UPDATE;  -- IX (on table) + X (on row id=1)

-- 트랜잭션 B
START TRANSACTION;
SELECT * FROM my_table WHERE id = 2 FOR UPDATE; -- IX (on table) + X (on row id=2)
</pre></table></code></div></div><ul><li>둘 다 같은 테이블에서 작업하지만 각각 다른 row에 row-level X 락을 요청<li>그래서 InnoDB는 테이블에 각각 IX 잠금을 설정함<li>IX와 IX는 호환되기 때문에 동시에 작업 가능</ul><h3 id="record-lock">Record Lock</h3><blockquote><p><strong>인덱스 레코드</strong>에 설정되는 잠금</p></blockquote><ul><li>예를 들어, <code class="language-plaintext highlighter-rouge">SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;</code> 는 <code class="language-plaintext highlighter-rouge">t.c1</code>이 10인 행을 다른 트랜잭션이 삽입, 수정, 삭제하지 못하도록 막는다.<li>레코드 락은 항상 인덱스 레코드를 대상으로 작동하며, <strong>테이블에 인덱스가 없어도 마찬가지이다.</strong><li>인덱스가 없는 경우, InnoDB는 숨겨진 클러스터형 인덱스를 자동으로 생성하고, 이를 사용해 레코드 잠금을 수행한다.</ul><p><strong>※ 인덱스 레코드 ?</strong></p><blockquote><p>인덱스에 저장된 각 항목(=행의 위치를 가리키는 엔트리) 즉, 실제 행 데이터가 아닌 <strong>인덱스 내부의 키와 포인터로 구성된 데이터 구조</strong></p></blockquote><ul><li>InnoDB는 모든 테이블을 클러스터형 인덱스(Primary Key 기반 B+트리) 구조로 저장<li>따라서, 어떤 행(row)을 찾고 수정할 때도 <strong>항상 인덱스를 통해 위치를 찾고 작업</strong><li>잠금의 대상이 되는 행은 곧 인덱스 레코드 상에 존재하는 엔트리이기 때문에, 인덱스 레코드 단위 락을 거는 것이 정확하고 효율적<li>gap lock, next-key lock 같은 락 전략도 전부 <strong>인덱스 레코드 사이 또는 레코드 + 갭 을 기준</strong>으로 동작</ul><h3 id="gap-lock">Gap Lock</h3><blockquote><p>인덱스 레코드들 <strong>사이의 간격</strong>이나, <strong>첫 번째 이전 또는 마지막 이후의 간격</strong>에 설정되는 잠금이다.</p></blockquote><ul><li>예를 들어 <code class="language-plaintext highlighter-rouge">SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;</code> 쿼리는, 해당 범위 내의 기존 값이 존재하든 아니든 관계없이, 다른 트랜잭션이 c1에 15를 삽입하지 못하게 막는다.<li>이는 <strong>해당 범위 내 모든 값들 사이의 간격</strong>에 갭 락이 걸리기 때문이다.<li>갭은 하나의 인덱스 값 사이일 수도 있고, 여러 값 사이일 수도 있으며, 심지어 아무 값이 없어도 갭이 존재할 수 있다.<li>갭 락은 성능과 동시성 간의 절충의 일부로, 일부 트랜잭션 격리 수준에서만 사용되고 다른 수준에서는 사용되지 않는다.<li><strong>유니크 인덱스</strong>를 통해 <strong>특정 행을 찾는 쿼리는 갭 락이 필요 없다.</strong><li>단, 다중 열 유니크 인덱스 중 <strong>일부 열만 조건에 포함된 경우</strong>에는 예외로, <strong>갭 락이 발생</strong>한다.<li>예를 들어, id 컬럼에 유니크 인덱스가 있다면 다음 쿼리는 id가 100인 행에만 레코드 잠금만 걸리고, 다른 세션이 그 앞에 값을 삽입하더라도 문제되지 않는다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">child</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>만약 id가 인덱스가 없거나 유니크하지 않은 인덱스라면, 해당 쿼리는 앞쪽 갭에도 잠금을 건다.<li>여기서 주목할 점은, 서로 충돌하는 락이 같은 갭에 대해 서로 다른 트랜잭션에 의해 유지될 수 있다는 것이다.<li>즉, <strong>갭 락(gap lock)은 공유/배타(S/X)라는 구분이 있지만, 실제로는 충돌하지 않는다.</strong><ul><li>예를 들어, 트랜잭션 A가 어떤 갭에 대해 공유 갭 락을 걸고 있는 동시에, 트랜잭션 B가 배타 갭 락을 같은 갭에 걸 수도 있다.</ul><li>서로 충돌하는 갭 락이 허용되는 이유는, 인덱스에서 어떤 레코드가 제거될 경우, 해당 레코드에 걸린 여러 트랜잭션의 갭 락을 병합해야 하기 때문이다.<li>InnoDB의 갭 락은 “순수하게 억제용” 으로, 그 목적은 다른 트랜잭션이 <strong>해당 갭에 값을 삽입하지 못하게 막는 것</strong>뿐이다.<ul><li><strong>공유 갭 락과 배타 갭 락은 실제로 차이가 없으며</strong>, 서로 충돌하지 않고, 같은 역할을 한다.</ul><li>갭 락은 명시적으로 비활성화될 수 있으며, 이는 트랜잭션 격리 수준을 <code class="language-plaintext highlighter-rouge">READ COMMITTED</code>로 바꿀 때 발생한다.<ul><li>이 경우, 갭 락은 검색이나 인덱스 스캔에서는 사용되지 않으며, 외래 키 제약 조건이나 중복 키 검사에만 사용된다.</ul><li>READ COMMITTED 격리 수준을 사용할 경우 기타 부수적인 효과들도 있다.<ul><li>WHERE 조건에 맞지 않는 레코드에 걸린 잠금은, MySQL이 조건을 평가한 후 즉시 해제된다.<li>UPDATE 문에 대해서 InnoDB는 “세미 일관성(semi-consistent)” 읽기를 수행하는데, 이는 MySQL에게 가장 최근 커밋된 버전을 전달하여 해당 행이 WHERE 조건에 맞는지 판단하도록 하는 방식이다.</ul></ul><p><strong>※ S/X 갭 락 차이가 없는데 구분하는 이유 ?</strong></p><ul><li>S Gap Lock과 X Gap Lock은 MySQL 사용자의 관점에서는 구분되지만, 내부적으로는 <strong>“갭에 대한 삽입 차단”</strong>이라는 동일한 효과를 가짐.<li>따라서 실제로는 갭을 잠갔는지 여부만 중요. 즉, 삽입이 가능/불가능이 핵심이지, “공유냐 배타냐”는 큰 의미가 없음<li>다만, 사용자 또는 SQL 구문 단위로는 정확한 트랜잭션 격리 수준 표현을 위해 구분함.<ul><li>즉, <strong>쿼리의 의도(intent)</strong>를 명확히 하기 위해 SQL 레벨에서 구분하는 것</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">:</span> <span class="nv">"나는 값을 수정할 수도 있어"</span> <span class="err">→</span> <span class="n">X</span> <span class="n">Gap</span> <span class="k">Lock</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">LOCK</span> <span class="k">IN</span> <span class="k">SHARE</span> <span class="k">MODE</span><span class="p">:</span> <span class="nv">"나는 읽기만 할 거야"</span> <span class="err">→</span> <span class="n">S</span> <span class="n">Gap</span> <span class="k">Lock</span>
</pre></table></code></div></div><p><strong>※ 필터링 조건과 갭 락</strong></p><ul><li>유니크 인덱스를 통해 특정 행을 찾는 쿼리는 갭 락이 필요 없다.<li>왜냐하면 이 경우 InnoDB는 정확히 하나의 행만 잠그면 되므로, 범위 전체를 잠글 필요가 없음<li>단, 다중 열 유니크 인덱스 중 일부 열만 조건에 포함된 경우에는 예외로, 갭 락이 발생한다.<ul><li>왜냐하면 조건이 애매하거나 불완전하면 MySQL이 정확히 하나의 행을 찾았는지 확신할 수 없기 때문</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">product</span> <span class="p">(</span>
  <span class="n">category_id</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="n">code</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
  <span class="n">price</span> <span class="nb">INT</span><span class="p">,</span>
  <span class="k">UNIQUE</span><span class="p">(</span><span class="n">category_id</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span>
<span class="p">);</span>

<span class="c1">-- 쿼리</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">product</span> <span class="k">WHERE</span> <span class="n">category_id</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">(category_id, code)</code>는 복합 유니크 인덱스<li>그런데 검색 조건은 category_id = 1만 포함됨 (불완전 조건)<ul><li>InnoDB는 “정확히 하나의 행만” 찾았는지 보장할 수 없음<li>따라서, 검색된 범위 전체에 next-key lock (record + gap) 걸게됨</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">product</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">123</span> <span class="k">FOR</span> <span class="k">UPDATE</span> <span class="k">LIMIT</span> <span class="mi">1</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>정확한 유니크 인덱스를 이용한 조건 + LIMIT<li>이 경우는 정확히 한 row만 찾아서 그 row만 record lock (X) 걸림</ul><h3 id="next-key-lock">Next-Key Lock</h3><blockquote><p>인덱스 레코드에 대한 레코드 락과, 그 앞에 있는 갭에 대한 갭 락의 조합</p></blockquote><ul><li>InnoDB는 테이블 인덱스를 검색하거나 스캔할 때, <strong>발견한 인덱스 레코드에 공유 또는 배타 잠금을 설정</strong>하는 방식으로 행 수준 잠금을 수행한다.<ul><li>따라서, 행 수준 잠금은 실제로는 인덱스 레코드 잠금이다.</ul></ul><div class="table-wrapper"><table><thead><tr><th>인덱스 유형<th>next-key lock 기준 컬럼<tbody><tr><td><strong>유니크 인덱스</strong> (단일/복합)<td><strong>모든 인덱스 컬럼이 완전히 조건에 포함되어야</strong> 정확히 1건만 잠금 (→ gap lock 없음)<tr><td><strong>비유니크 복합 인덱스</strong><td><strong>첫 번째 컬럼 기준으로 범위 스캔</strong>, 스캔된 범위의 <strong>모든 레코드에 next-key lock</strong> 발생</table></div><ul><li>인덱스 레코드에 설정된 넥스트키 락은 <strong>해당 인덱스 레코드 바로 앞의 갭</strong>에도 영향을 미친다.<li>즉, 넥스트키 락은 <strong>인덱스 레코드 잠금 + 그 앞 갭에 대한 갭 락</strong>이다.<li>따라서, 한 세션이 인덱스에서 레코드 R에 대해 공유 또는 배타 잠금을 가지고 있다면, 다른 세션은 R 바로 앞의 갭에 새로운 인덱스 레코드를 삽입할 수 없다.</ul><p><strong>예시</strong></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>-- 인덱스에 값이 10, 11, 13, 20이 있다고 가정
-- 이 인덱스에 대해 가능한 넥스트키 락은 다음 구간들을 포함
-- (소괄호는 끝점 제외, 대괄호는 끝점 포함)

(-무한대, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +무한대)
</pre></table></code></div></div><ul><li>마지막 구간에서는, 넥스트키 락이 인덱스에서 가장 큰 값보다 위에 있는 갭과, 실제 인덱스 값보다 큰 값을 가지는 “supremum” 가상 레코드를 잠근다.<li>supremum은 실제 인덱스 레코드가 아니므로, 결국 이 넥스트키 락은 가장 큰 인덱스 값 이후의 갭만 잠그는 것과 같다.<li>기본적으로 InnoDB는 REPEATABLE READ 트랜잭션 격리 수준에서 동작한다.<li>이 경우 InnoDB는 검색과 인덱스 스캔에 넥스트키 락을 사용하여, <strong>팬텀 레코드(phantom row)의 발생을 방지</strong>한다.</ul><h3 id="insert-intention-locks">Insert Intention Locks</h3><blockquote><p>INSERT 작업이 행을 실제로 <strong>삽입하기 전</strong>에 설정하는 일종의 <strong>갭 락(gap lock)</strong></p></blockquote><ul><li>이 잠금은 <strong>같은 인덱스 갭</strong>에 삽입하려는 의도를 표시하며, 서로 다른 위치에 삽입하는 경우에는 트랜잭션끼리 서로 <strong>대기하지 않도록</strong> 해준다.</ul><p><strong>예시1</strong></p><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">-- 데이터 세팅</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child</span> <span class="p">(</span><span class="n">id</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">90</span><span class="p">),(</span><span class="mi">102</span><span class="p">);</span>
</pre></table></code></div></div><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">-- 트랜잭션 A</span>

<span class="k">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">101</span><span class="p">);</span> <span class="c1">-- (90, 102) 갭에 Insert Intention Lock이 걸림</span>
</pre></table></code></div></div><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">-- 트랜잭션 B</span>

<span class="k">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">95</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>트랜잭션 B에서 동일하게 (90, 102) 갭에 Insert Intention Lock을 잡지만 Insert Intention Lock끼리는 호환되므로 대기없이 바로 Insert 가능</ul><p><strong>예시2</strong></p><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">-- 데이터 세팅</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child</span> <span class="p">(</span><span class="n">id</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">90</span><span class="p">),(</span><span class="mi">102</span><span class="p">);</span>
</pre></table></code></div></div><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">-- 트랜잭션 A</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">child</span> <span class="p">(</span><span class="n">id</span> <span class="nb">int</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="n">ENGINE</span><span class="o">=</span><span class="n">InnoDB</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">values</span> <span class="p">(</span><span class="mi">90</span><span class="p">),(</span><span class="mi">102</span><span class="p">);</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">child</span> <span class="k">WHERE</span> <span class="n">id</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span> <span class="c1">-- 102 레코드에 배타 잠금 + 그 앞 갭에 갭 락 발생</span>

<span class="o">+</span><span class="c1">-----+</span>
<span class="o">|</span> <span class="n">id</span>  <span class="o">|</span>
<span class="o">+</span><span class="c1">-----+</span>
<span class="o">|</span> <span class="mi">102</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-----+</span>
</pre></table></code></div></div><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">-- 트랜잭션 B</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">child</span> <span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="k">VALUES</span> <span class="p">(</span><span class="mi">101</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>트랜잭션 B에서 101을 삽입하려고 하지만, A의 <code class="language-plaintext highlighter-rouge">FOR UPDATE가 id &gt; 100</code> 범위의 갭을 이미 잠가버렸기 때문에, B는 insert intention lock을 걸고 기다리게 됨.<br /> (즉, 갭 락과는 호환되지 않음)</ul><h2 id="확인해보기">확인해보기</h2><blockquote><p>데이터 세팅</p></blockquote><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">students</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">INT</span> <span class="n">AUTO_INCREMENT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">class_no</span> <span class="nb">INT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
    <span class="n">age</span> <span class="nb">INT</span><span class="p">,</span>
    <span class="k">INDEX</span> <span class="n">idx_class_no_name</span> <span class="p">(</span><span class="n">class_no</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">students</span> <span class="p">(</span><span class="n">class_no</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="k">VALUES</span>

<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Alice'</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Bob'</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Charlie'</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Alice'</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'David'</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Eve'</span><span class="p">,</span> <span class="mi">14</span><span class="p">),</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'Frank'</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'Grace'</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'Bob'</span><span class="p">,</span> <span class="mi">15</span><span class="p">),</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'Heidi'</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>
</pre></table></code></div></div><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">students</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">class_no</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>class_no<th>name<th>age<tbody><tr><td>1<td>1<td>Alice<td>14<tr><td>2<td>1<td>Bob<td>15<tr><td>6<td>1<td>Eve<td>14<tr><td>9<td>1<td>Bob<td>15<tr><td>3<td>2<td>Charlie<td>13<tr><td>4<td>2<td>Alice<td>14<tr><td>7<td>2<td>Frank<td>15<tr><td>5<td>3<td>David<td>16<tr><td>8<td>3<td>Grace<td>13<tr><td>10<td>3<td>Heidi<td>14</table></div><p>※ 참고</p><ul><li>쿼리 수행후 락 관련 정보는 다음 쿼리로 확인</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="n">object_name</span><span class="p">,</span> <span class="n">index_name</span><span class="p">,</span> <span class="n">lock_type</span><span class="p">,</span> <span class="n">lock_mode</span><span class="p">,</span> <span class="n">lock_data</span>
<span class="k">FROM</span> <span class="n">performance_schema</span><span class="p">.</span><span class="n">data_locks</span><span class="p">;</span>
</pre></table></code></div></div><p><strong>performance_schema.data_locks에서의 lock_mode 해석</strong></p><ul><li><code class="language-plaintext highlighter-rouge">X</code><ul><li>보통 Next-Key Lock을 의미<li>하지만, 이 정보만으로는 정확하게 Record-only Lock인지 Next-Key Lock인지 구분이 안 될 수도 있음</ul><li><code class="language-plaintext highlighter-rouge">X_REC_NOT_GAP</code><ul><li>명확하게 Record-only Lock을 의미<li>즉, 해당 레코드만 잠그고 GAP은 잠그지 않음<li>대표적으로 Unique Index로 정확하게 일치하는 값을 조회할 때 발생</ul><li><code class="language-plaintext highlighter-rouge">X,GAP</code><ul><li>Gap Lock만 발생한 경우로, 보통 범위 조건이나 범위 외 레코드가 없을 때 발생</ul></ul><h3 id="test1">TEST1</h3><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">students</span>
<span class="k">WHERE</span> <span class="n">class_no</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>object_name<th>index_name<th>lock_type<th>lock_mode<th>lock_data<tbody><tr><td>students<td><em>(NULL)</em><td>TABLE<td>IX<td><em>(NULL)</em><tr><td>students<td>idx_class_no_name<td>RECORD<td>X,GAP<td>2, ‘Alice’, 4<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Alice’, 1<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Bob’, 2<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Eve’, 6<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Bob’, 9<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>1<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>2<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>6<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>9</table></div><h3 id="test2">TEST2</h3><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">students</span>
<span class="k">WHERE</span> <span class="n">class_no</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">AND</span> <span class="n">age</span> <span class="o">&lt;</span> <span class="mi">15</span>
<span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>object_name<th>index_name<th>lock_type<th>lock_mode<th>lock_data<tbody><tr><td>students<td><em>(NULL)</em><td>TABLE<td>IX<td><em>(NULL)</em><tr><td>students<td>idx_class_no_name<td>RECORD<td>X,GAP<td>2, ‘Alice’, 4<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Alice’, 1<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Bob’, 2<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Eve’, 6<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Bob’, 9<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>1<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>2<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>6<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>9</table></div><ul><li><code class="language-plaintext highlighter-rouge">age &lt; 15</code>인 조건에 포함되는 레코드는 2개지만, <code class="language-plaintext highlighter-rouge">age = 15</code>인 레코드도 스캔 대상에 들어가서 불필요하게 락이 잡히게된다.</ul><h3 id="test3">TEST3</h3><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">students</span>
<span class="k">WHERE</span> <span class="n">class_no</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">LIMIT</span> <span class="mi">2</span>
<span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>object_name<th>index_name<th>lock_type<th>lock_mode<th>lock_data<tbody><tr><td>students<td><em>(NULL)</em><td>TABLE<td>IX<td><em>(NULL)</em><tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Alice’, 1<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Bob’, 2<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>1<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>2</table></div><ul><li>처음부터 2개만 스캔하기 때문에, 정렬된 순서대로 2개만 락이 걸림</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">students</span>
<span class="k">WHERE</span> <span class="n">class_no</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">LIMIT</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span>
<span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>object_name<th>index_name<th>lock_type<th>lock_mode<th>lock_data<tbody><tr><td>students<td><em>(NULL)</em><td>TABLE<td>IX<td><em>(NULL)</em><tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Alice’, 1<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Bob’, 2<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Eve’, 6<tr><td>students<td>idx_class_no_name<td>RECORD<td>X<td>1, ‘Bob’, 9<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>1<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>2<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>6<tr><td>students<td>PRIMARY<td>RECORD<td>X_REC_NOT_GAP<td>9</table></div><ul><li>LIMIT으로 2개만 리턴하지만 2부터이므로, 결국 4개 스캔하는거라 4개 모두 락 걸림</ul><h3 id="test4">TEST4</h3><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">students</span>
<span class="k">WHERE</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="mi">5</span>
<span class="k">FOR</span> <span class="k">UPDATE</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>object_name<th>index_name<th>lock_type<th>lock_mode<th>lock_data<tbody><tr><td>students<td><em>(NULL)</em><td>TABLE<td>IX<td><em>(NULL)</em><tr><td>students<td>PRIMARY<td>RECORD<td>X,GAP<td>5<tr><td>students<td>PRIMARY<td>RECORD<td>X<td>1<tr><td>students<td>PRIMARY<td>RECORD<td>X<td>2<tr><td>students<td>PRIMARY<td>RECORD<td>X<td>3<tr><td>students<td>PRIMARY<td>RECORD<td>X<td>4</table></div><ul><li>4,5 사이에 아무것도 들어갈 수 없는데 왜 갭락이 걸릴까 ?<ul><li>사용자가 어떤 제약 조건을 갖고 있든 간에, InnoDB는 B+Tree 인덱스 구조만 보고 범위를 판단하고 잠금을 건다.<li>즉, id가 AUTO_INCREMENT든, PRIMARY KEY든, 중간 삽입이 불가능하든 그건 InnoDB 입장에서 알 수 없는 정보</ul></ul><div class="table-wrapper"><table><thead><tr><th>범위<th>걸리는 잠금 종류<tbody><tr><td><code class="language-plaintext highlighter-rouge">(-∞, 1)</code><td><code class="language-plaintext highlighter-rouge">GAP</code> only<tr><td><code class="language-plaintext highlighter-rouge">[1]</code><td><code class="language-plaintext highlighter-rouge">X</code> (Next-Key Lock)<tr><td><code class="language-plaintext highlighter-rouge">(1, 2)</code><td><code class="language-plaintext highlighter-rouge">GAP</code> 포함 → [2]도 마찬가지<tr><td><code class="language-plaintext highlighter-rouge">[2]</code><td><code class="language-plaintext highlighter-rouge">X</code> (Next-Key Lock)<tr><td>…<td>…<tr><td><code class="language-plaintext highlighter-rouge">[4]</code><td><code class="language-plaintext highlighter-rouge">X</code> (Next-Key Lock)<tr><td><code class="language-plaintext highlighter-rouge">(4, 5)</code><td>→ <code class="language-plaintext highlighter-rouge">id=5</code>에 <code class="language-plaintext highlighter-rouge">X,GAP</code></table></div><h3 id="test5">TEST5</h3><blockquote><p>유니크 인덱스 <code class="language-plaintext highlighter-rouge">email</code> 추가</p></blockquote><ul><li>Tx1<ul><li><code class="language-plaintext highlighter-rouge">INSERT STUDENTS (class_no, email, name, age, flag) VALUES (5, 'email@test.com', 'lee', 10, 'N');</code></ul></ul><div class="table-wrapper"><table><thead><tr><th>object_name<th>index_name<th>lock_type<th>lock_mode<th>lock_data<tbody><tr><td>students<td><em>(NULL)</em><td>TABLE<td>IX<td><em>(NULL)</em></table></div><ul><li>Tx2<ul><li><code class="language-plaintext highlighter-rouge">INSERT STUDENTS (class_no, email, name, age, flag) VALUES (5, 'email@test.com', 'kim', 10, 'N');</code></ul></ul><div class="table-wrapper"><table><thead><tr><th>object_name<th>index_name<th>lock_type<th>lock_mode<th>lock_data<tbody><tr><td>students<td><em>(NULL)</em><td>TABLE<td>IX<td><em>(NULL)</em><tr><td>students<td><em>(NULL)</em><td>TABLE<td>IX<td><em>(NULL)</em><tr><td>students<td>idx_email<td>RECORD<td>X,REC_NOT_GAP<td>‘email@test.com’, 17<tr><td>students<td>idx_email<td>RECORD<td>S<td>‘email@test.com’, 17</table></div><ul><li>Tx2도 동일한 이메일로 INSERT를 시도함.<li>MySQL은 UNIQUE 제약 위반 가능성이 있으므로 다음을 수행:<ul><li>UNIQUE 인덱스를 조회하여 <code class="language-plaintext highlighter-rouge">email@test.com</code>이 존재하는지 확인<li>이 과정에서 인덱스 키 <code class="language-plaintext highlighter-rouge">email@test.com'에</code>대해 S Lock (공유 잠금)을 걸어 존재 유무를 확인<li>하지만, Tx1이 이미 인덱스 레코드 락 (X, REC_NOT_GAP)을 잡고 있어서, Tx2는 대기(blocking) 상태</ul></ul><h2 id="참고-자료">참고 자료</h2><ul><li><a href="https://dev.mysql.com/doc/refman/8.4/en/innodb-locking.html">https://dev.mysql.com/doc/refman/8.4/en/innodb-locking.html</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EC%A7%80%EC%8B%9D-%EB%8D%94%ED%95%98%EA%B8%B0/'>지식 더하기</a>, <a href='/categories/%EC%9D%B4%EB%A1%A0/'>이론</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/mysql/" class="post-tag no-text-decoration" >MySQL</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MySQL - LOCK 살펴보기 - zz9z9&url=https://zz9z9.github.io/posts/mysql-lock/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MySQL - LOCK 살펴보기 - zz9z9&u=https://zz9z9.github.io/posts/mysql-lock/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=MySQL - LOCK 살펴보기 - zz9z9&url=https://zz9z9.github.io/posts/mysql-lock/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/jpa-entity-manager-persistence-context/">EntityManager와 영속성 컨텍스트</a><li><a href="/posts/jpa-id-generation-strategy/">JPA/Hibernate ID 생성 전략</a><li><a href="/posts/aws-vpc/">AWS VPC(Virtual Private Cloud) - 기초 개념</a><li><a href="/posts/aws-efs/">AWS EFS(Elastic File System) - 기초 개념</a><li><a href="/posts/aws-intro/">AWS - 상품 살펴보기</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/web/">WEB</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/hibernate/">Hibernate</a> <a class="post-tag" href="/tags/http/">HTTP</a> <a class="post-tag" href="/tags/spring-batch/">Spring Batch</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/transaction-and-isolation-level/"><div class="card-body"> <span class="timeago small" > Aug 24, 2021 <i class="unloaded">2021-08-24T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL - 트랜잭션과 격리 수준</h3><div class="text-muted small"><p> 트랜잭션과 ACID 트랜잭션이란 ? 데이터베이스 상태를 변경시키는 일련의 연산들을 논리적으로 묶을 수 있는 하나의 작업 단위 ex) 주문 - 결제 - 결제 승인 - 주문 접수 트랜잭션에는 중요한 두 가지 목적이 있다. ...</p></div></div></a></div><div class="card"> <a href="/posts/data-modeling/"><div class="card-body"> <span class="timeago small" > Aug 25, 2021 <i class="unloaded">2021-08-25T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL - 데이터 모델링</h3><div class="text-muted small"><p> 들어가기 전 애플리케이션을 설계할 때 ‘DB 테이블은 어떻게 구성해야하지?’ 에 대한 막막함이 있다면 데이터 모델링이 문제 해결의 출발점이라고 생각한다. 공부를 하기에 앞서 나의 언어로 정리해본다면 내가 생각하기에 모델링이라는 것은 먼저 문자 그대로 ‘모델화’ 시킨다는 것인데, 모델이란 ‘어떤 대상을 필요한 특징만 추려서 나타낸 것’ 이라는 생...</p></div></div></a></div><div class="card"> <a href="/posts/mysql-architecture/"><div class="card-body"> <span class="timeago small" > Oct 6, 2021 <i class="unloaded">2021-10-06T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL - MySQL 내부 구조 간단히 살펴보기</h3><div class="text-muted small"><p> 들어가기 전 슬로우 쿼리를 고쳐보고 싶은데 고치려면 어떻게 해야할지에 대한 지식이 전혀없다. 근데 슬로우 쿼리는 차치하고, 쿼리가 어떻게 동작하고 DB 내부는 어떻게 생긴지에 대해서도 공부해보지 않았다. 그래서 먼저 MySQL을 기준으로 내부 구조가 어떤지 세부적인 내용을 제외하고 간단하게 정리해보려고 한다. MySQL의 전체적인 구조 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/mysql-readview/" class="btn btn-outline-primary" prompt="Older"><p>MySQL - ReadView 들여다보기</p></a> <a href="/posts/sxssf-memory-flush/" class="btn btn-outline-primary" prompt="Newer"><p>SXSSF를 사용하는데 OOM이 발생한다 ?</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/username">Lee JaeYoon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/web/">WEB</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/hibernate/">Hibernate</a> <a class="post-tag" href="/tags/http/">HTTP</a> <a class="post-tag" href="/tags/spring-batch/">Spring Batch</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://zz9z9.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
