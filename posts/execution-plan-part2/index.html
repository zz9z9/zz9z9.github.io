<!DOCTYPE html><html lang="en-US" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="MySQL - MySQL 실행 계획 (2)" /><meta property="og:locale" content="en_US" /><meta name="description" content="들어가기 전 실행 계획을 나타내는 테이블의 다양한 컬럼들 중 먼저 id, select_type, table, type 컬럼에 대해 살펴볼 것이다." /><meta property="og:description" content="들어가기 전 실행 계획을 나타내는 테이블의 다양한 컬럼들 중 먼저 id, select_type, table, type 컬럼에 대해 살펴볼 것이다." /><link rel="canonical" href="https://zz9z9.github.io/posts/execution-plan-part2/" /><meta property="og:url" content="https://zz9z9.github.io/posts/execution-plan-part2/" /><meta property="og:site_name" content="zz9z9" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-07T23:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MySQL - MySQL 실행 계획 (2)" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-10-07T23:00:00+09:00","datePublished":"2021-10-07T23:00:00+09:00","description":"들어가기 전 실행 계획을 나타내는 테이블의 다양한 컬럼들 중 먼저 id, select_type, table, type 컬럼에 대해 살펴볼 것이다.","headline":"MySQL - MySQL 실행 계획 (2)","mainEntityOfPage":{"@type":"WebPage","@id":"https://zz9z9.github.io/posts/execution-plan-part2/"},"url":"https://zz9z9.github.io/posts/execution-plan-part2/"}</script><title>MySQL - MySQL 실행 계획 (2) | zz9z9</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="zz9z9"><meta name="application-name" content="zz9z9"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-Q7PWLG5WYT"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Q7PWLG5WYT'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Soccerball.svg/1000px-Soccerball.svg.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">zz9z9</a></div><div class="site-subtitle font-italic">거창한 계획보다는, 꾸준한 실행을</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/zz9z9" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>MySQL - MySQL 실행 계획 (2)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>MySQL - MySQL 실행 계획 (2)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Lee JaeYoon </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Thu, Oct 7, 2021, 11:00 PM +0900" prep="on" > Oct 7, 2021 <i class="unloaded">2021-10-07T23:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4464 words">24 min</span></div></div><div class="post-content"><h1 id="들어가기-전">들어가기 전</h1><hr /><p>실행 계획을 나타내는 테이블의 다양한 컬럼들 중 먼저 id, select_type, table, type 컬럼에 대해 살펴볼 것이다. <br /></p><p>※ <a href="https://zz9z9.github.io/posts/execution-plan-part1/">이전 글</a>을 읽지 않으신 분들은 먼저 읽으실 것을 권장합니다.</p><h1 id="id-컬럼">id 컬럼</h1><hr /><blockquote><p>단위 SELECT 쿼리별로 부여되는 식별자 값을 나타내는 컬럼이다.</p></blockquote><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">SELECT</span><span class="p">...</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="p">...</span> <span class="k">FROM</span> <span class="n">tb_test1</span><span class="p">)</span> <span class="n">tb1</span><span class="p">,</span>
  <span class="n">tb_test2</span> <span class="n">tb2</span>
<span class="k">WHERE</span> <span class="n">tb1</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">tb2</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>위 쿼리는 아래와 같이 <code class="language-plaintext highlighter-rouge">SELECT</code> 단위로 분리해서 생각해볼 수 있다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="p">...</span> <span class="k">FROM</span> <span class="n">tb_test1</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="p">...</span> <span class="k">FROM</span> <span class="n">tb1</span><span class="p">,</span> <span class="n">tb_test2</span> <span class="n">tb2</span> <span class="k">WHERE</span> <span class="n">tb1</span><span class="p">.</span><span class="n">id</span><span class="o">=</span><span class="n">tb2</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>하나의 SELECT 문장 안에서 여러 개의 테이블을 조인하면 각 레코드별로 같은 id가 부여된다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">from_date</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">salary</span>
<span class="k">FROM</span> <span class="n">employees</span> <span class="n">e</span><span class="p">,</span> <span class="n">salaries</span> <span class="n">s</span>
<span class="k">WHERE</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="o">=</span><span class="n">s</span><span class="p">.</span><span class="n">emp_no</span>
<span class="k">LIMIT</span> <span class="mi">10</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>e<td>index<td>ix_firstname<td>44<td> <td>300584<td>Using index<tr><td>1<td>SIMPLE<td>s<td>ref<td>PRIMARY<td>4<td>employees, e.emp_no<td>4<td> </table></div><ul><li>다음과 같이 3개의 단위 SELECT 쿼리로 구성된 경우는 아래와 같은 실행 계획을 나타낼 것이다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span>
<span class="p">(</span> <span class="p">(</span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">employees</span><span class="p">)</span> <span class="o">+</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">departments</span><span class="p">)</span> <span class="p">)</span> <span class="k">AS</span> <span class="n">total_count</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td> <td> <td> <td> <td> <td> <td>No tables used<tr><td>2<td>SUBQUERY<td>employees<td>index<td>ix_hiredate<td>3<td> <td>300584<td>Using index<tr><td>3<td>SUBQUERY<td>departments<td>index<td>ux_deptname<td>123<td> <td>9<td>Using index</table></div><h1 id="select_type-컬럼">select_type 컬럼</h1><hr /><blockquote><p>각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 컬럼이다.</p></blockquote><h2 id="simple">SIMPLE</h2><ul><li><code class="language-plaintext highlighter-rouge">UNION</code>이나 서브 쿼리를 사용하지 않는 단순한 <code class="language-plaintext highlighter-rouge">SELECT</code> 쿼리인 경우이다.<li>실행 계획에서 select_type이 ‘SIMPLE’인 단위 쿼리는 반드시 하나만 존재한다.<li>일반적으로 제일 바깥 <code class="language-plaintext highlighter-rouge">SELECT</code> 쿼리의 select_type이 ‘SIMPLE’로 표시된다.</ul><h2 id="primary">PRIMARY</h2><ul><li><code class="language-plaintext highlighter-rouge">UNION</code>이나 서브 쿼리가 포함된 <code class="language-plaintext highlighter-rouge">SELECT</code> 쿼리의 실행 계획에서 가장 바깥쪽(Outer)에 있는 단위 쿼리인 경우이다.<li>실행 계획에서 select_type이 ‘PRIMARY’인 단위 쿼리는 반드시 하나만 존재한다.</ul><h2 id="union">UNION</h2><ul><li><code class="language-plaintext highlighter-rouge">UNION</code>으로 결합하는 단위 <code class="language-plaintext highlighter-rouge">SELECT</code> 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 <code class="language-plaintext highlighter-rouge">SELECT</code> 쿼리는 <code class="language-plaintext highlighter-rouge">UNION</code>으로 표시된다.<li><code class="language-plaintext highlighter-rouge">UNION</code>의 첫 번째 단위 <code class="language-plaintext highlighter-rouge">SELECT</code>는 <code class="language-plaintext highlighter-rouge">UNION</code> 쿼리로 결합된 전체 집합의 select_type이 표시된다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="p">(</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="n">emp_no</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="n">e1</span> <span class="k">LIMIT</span> <span class="mi">10</span><span class="p">)</span>
  <span class="k">UNION</span> <span class="k">ALL</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="n">emp_no</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="n">e2</span> <span class="k">LIMIT</span> <span class="mi">10</span><span class="p">)</span>
  <span class="k">UNION</span> <span class="k">ALL</span>
  <span class="p">(</span><span class="k">SELECT</span> <span class="n">emp_no</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="n">e3</span> <span class="k">LIMIT</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">)</span> <span class="n">tb</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td>&lt; derived2 &gt;<td>ALL<td> <td> <td> <td>30<td> <tr><td>2<td>DERIVED<td>e1<td>index<td>ix_hiredate<td>3<td> <td>300584<td>Using index<tr><td>3<td>UNION<td>e2<td>index<td>ix_hiredate<td>3<td> <td>300584<td>Using index<tr><td>4<td>UNION<td>e3<td>index<td>ix_hiredate<td>3<td> <td>300584<td>Using index<tr><td> <td>UNION RESULT<td>&lt;union2,3,4&gt;<td>ALL<td> <td> <td> <td> <td> </table></div><h2 id="dependent-union">DEPENDENT UNION</h2><ul><li><code class="language-plaintext highlighter-rouge">UNION</code>이나 <code class="language-plaintext highlighter-rouge">UNION ALL</code>로 집합을 결합하는 쿼리에서 표시된다.<li>‘DEPENDENT’는 <code class="language-plaintext highlighter-rouge">UNION</code>이나 <code class="language-plaintext highlighter-rouge">UNION ALL</code>로 결합된 단위 쿼리가 외부의 영향을 받은 것을 의미한다.<ul><li>외부의 영향이란, 내부 쿼리가 외부의 값을 참조해서 처리하는 것을 의미한다.</ul><li>일반적으로 외부 쿼리보다 서브 쿼리가 먼저 실행되며, 대부분 이러한 방식이 반대의 경우보다 더 빠르다.<ul><li>하지만 ‘DEPENDENT’ 키워드가 포함되는 경우, 서브 쿼리는 외부 쿼리에 의존적이므로 절대 외부 쿼리보다 먼저 실행될 수가 없다.<li>따라서 이러한 쿼리는 비효율적인 경우가 많다.</ul><li>아래 쿼리에서는 내부 쿼리에서 외부에 있는 employees 테이블의 emp_no 컬럼이 사용된다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span>
 <span class="n">e</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span>
 <span class="p">(</span> <span class="k">SELECT</span> <span class="p">...</span> <span class="k">FROM</span> <span class="n">salaries</span> <span class="n">s</span> <span class="k">WHERE</span> <span class="n">s</span><span class="p">.</span><span class="n">emp_no</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span>
   <span class="k">UNION</span>
   <span class="k">SELECT</span> <span class="p">...</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="n">de</span> <span class="k">WHERE</span> <span class="n">de</span><span class="p">.</span><span class="n">emp_no</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span>
 <span class="p">)</span> <span class="k">AS</span> <span class="n">msg</span>
<span class="k">FROM</span> <span class="n">employees</span> <span class="n">e</span>
<span class="k">WHERE</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="o">=</span><span class="mi">10001</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td>e<td>const<td>PRIMARY<td>4<td>const<td>1<td> <tr><td>2<td>DEPENDENT<br />SUBQUERY<td>s<td>ref<td>PRIMARY<td>4<td>const<td>17<td>Using index<tr><td>3<td>DEPENDENT<br />UNION<td>de<td>ref<td>ix_empno_fromdate<td>4<td> <td>1<td>Using where;<br />Using index<tr><td> <td>UNION RESULT<td>&lt;union2,3&gt;<td>ALL<td> <td> <td> <td> <td> </table></div><h2 id="union-result">UNION RESULT</h2><ul><li>MySQL에서 <code class="language-plaintext highlighter-rouge">UNION</code>이나 <code class="language-plaintext highlighter-rouge">UNION ALL</code> 쿼리는 모두 병합 결과를 임시 테이블로 생성한다.<li>‘UNION RESULT’는 이러한 임시 테이블을 의미한다.<ul><li>단위 쿼리가 아니기 때문에 별도 id 값은 부여되지 않는다.</ul><li>table 컬럼의 <code class="language-plaintext highlighter-rouge">&lt;union n,m&gt;</code>의 의미는 id가 n번, m번인 단위 쿼리의 결과를 <code class="language-plaintext highlighter-rouge">UNION</code> 했다는 것을 의미한다.</ul><h2 id="subquery">SUBQUERY</h2><ul><li>여기서 ‘SUBQUERY’라고 하는 것은 <code class="language-plaintext highlighter-rouge">FROM</code> 절 이외에서 사용되는 서브 쿼리만을 의미한다.<li><code class="language-plaintext highlighter-rouge">FROM</code> 절에 사용된 서브 쿼리는 ‘DERIVED’라고 표시된다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span>
  <span class="n">e</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span>
  <span class="p">(</span> <span class="k">SELECT</span> <span class="p">...</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="n">de</span><span class="p">,</span> <span class="n">dept_manager</span> <span class="n">dm</span> <span class="k">WHERE</span> <span class="p">...)</span> <span class="k">AS</span> <span class="n">cnt</span>
<span class="k">FROM</span> <span class="n">employees</span> <span class="n">e</span>
<span class="k">WHERE</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span> <span class="o">=</span> <span class="mi">10001</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td>e<td>const<td>PRIMARY<td>4<td>const<td>1<td> <tr><td>2<td>SUBQUERY<td>dm<td>index<td>PRIMARY<td>16<td> <td>24<td>Using index<tr><td>2<td>SUBQUERY<td>de<td>ref<td>PRIMARY<td>12<td>dm.dept_no<td>18603<td>Using index</table></div><h2 id="dependent-subquery">DEPENDENT SUBQUERY</h2><ul><li>서브 쿼리가 바깥쪽(Outer) SELECT 쿼리에서 정의된 컬럼을 사용하는 경우이다.<li>‘DEPENDENT UNION’처럼 ‘DEPENDENT SUBQUERY’ 또한 외부 쿼리가 먼저 수행된 후 내부 쿼리(서브 쿼리)가 실행되어야 하므로 일반 서브 쿼리보다는 처리 속도가 느릴 때가 많다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span>
  <span class="n">e</span><span class="p">.</span><span class="n">first_name</span><span class="p">,</span>
  <span class="p">(</span> <span class="k">SELECT</span> <span class="p">...</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="n">de</span><span class="p">,</span> <span class="n">dept_manager</span> <span class="n">dm</span> <span class="k">WHERE</span> <span class="p">...</span> <span class="k">AND</span> <span class="n">de</span><span class="p">.</span><span class="n">emp_no</span><span class="o">=</span><span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="p">)</span> <span class="k">AS</span> <span class="n">cnt</span>
<span class="k">FROM</span> <span class="n">employees</span> <span class="n">e</span>
<span class="k">WHERE</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span> <span class="o">=</span> <span class="mi">10001</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td>e<td>const<td>PRIMARY<td>4<td>const<td>1<td> <tr><td>2<td>DEPENDENT<br />SUBQUERY<td>de<td>ref<td>ix_empno_fromdate<td>4<td> <td>1<td>Using<br />index<tr><td>2<td>DEPENDENT<br />SUBQUERY<td>dm<td>ref<td>PRIMARY<td>12<td>dm.dept_no<td>1<td>Using<br />index</table></div><h2 id="derived">DERIVED</h2><ul><li>서브 쿼리가 <code class="language-plaintext highlighter-rouge">FROM</code> 절에 사용된 경우이다.<li>‘DERIVED’인 경우, 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블로 생성한다.<ul><li>이러한 임시 테이블을 ‘파생 테이블’이라고도 한다.<li>파생 테이블에는 인덱스가 없으므로 다른 테이블과 조인할 때 성능상 불리할 때가 많다.</ul><li>MySQL은 이러한 서브 쿼리를 최적화하지 못할 때가 대부분이다. (MySQL 5 기준)<li>쿼리를 튜닝하기 위해 가장 먼저하는 것 중 하나가 select_type 값이 ‘DERIVED’인 것이 있는지 찾는 것이다.<ul><li>이 경우, 조인으로 해결할 수 있는 경우라면 서브 쿼리보다는 조인을 사용하는 것이 권장된다.</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">de</span><span class="p">.</span><span class="n">emp_no</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="n">de</span><span class="p">)</span> <span class="n">tb</span><span class="p">,</span>
    <span class="n">employees</span> <span class="n">e</span>
<span class="k">WHERE</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="o">=</span><span class="n">tb</span><span class="p">.</span><span class="n">emp_no</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td>&lt; derived2 &gt;<td>ALL<td> <td> <td> <td>331603<td> <tr><td>1<td>PRIMARY<td>e<td>eq_ref<td>PRIMARY<td>4<td>tb.emp_no<td>1<td>Using<br />index<tr><td>2<td>DERIVED<td>de<td>index<td>ix_fromdate<td>3<td> <td>334868<td>Using<br />index</table></div><h2 id="uncacheable-subquery">UNCACHEABLE SUBQUERY</h2><ul><li>일반적으로 조건이 똑같은 서브 쿼리가 실행될 때, 이전의 실행 결과를 그대로 사용한다.<ul><li>재사용을 위해 서브 쿼리의 결과를 내부적인 캐시 공간에 담아둔다.<li>쿼리 캐시나 파생 테이블과는 무관하다.</ul><li>하지만 ‘UNCACHEABLE SUBQUERY’로 표시될 때는 캐싱된 결과를 사용할 수 없는 경우이다.<ul><li>사용자 변수가 서브 쿼리에 사용된 경우<li><code class="language-plaintext highlighter-rouge">NOT-DETERMINISTIC</code> 속성의 스토어드 루틴이 서브 쿼리에 내에 사용된 경우<li><code class="language-plaintext highlighter-rouge">UUID()</code>나 <code class="language-plaintext highlighter-rouge">RAND()</code>와 같이 결과값이 호출할 때마다 달라지는 함수가 서브 쿼리에 사용된 경우</ul></ul><h2 id="uncacheble-union">UNCACHEBLE UNION</h2><ul><li><code class="language-plaintext highlighter-rouge">UNION</code>을 사용한 쿼리 중 위에서 언급한 캐싱할 수 없는 조건에 해당하는 경우이다.<li>MySQL 5.1부터 추가된 select_type이다.</ul><h1 id="table-컬럼">table 컬럼</h1><hr /><blockquote><p>MySQL의 실행 계획은 테이블 기준으로 표시된다. 별도의 테이블을 사용하지 않는 경우에는 <code class="language-plaintext highlighter-rouge">NULL</code>이 표시된다.</p></blockquote><ul><li>table 컬럼에 “&lt;&gt;”로 둘러싸인 이름이 표시되는 경우는 임시 테이블을 의미한다.<li>지금까지 공부한 내용을 토대로 다음 실행 계획을 분석해보자.</ul><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td><code class="language-plaintext highlighter-rouge">&lt;derived2&gt;</code><td>ALL<td> <td> <td> <td>10420<td> <tr><td>1<td>PRIMARY<td>e<td>eq_ref<td>PRIMARY<td>4<td>de1.emp_no<td>1<td> <tr><td>2<td>DERIVED<td>dept_emp<td>range<td>ix_fromdate<td>3<td> <td>20550<td> </table></div><ol><li>첫 번째 라인의 테이블이 <code class="language-plaintext highlighter-rouge">&lt;derived2&gt;</code>이므로 id가 2번인 라인이 먼저 실행되고 그 결과로 파생 테이블이 만들어진다.<li>id 2번에 table이 dept_emp인 것으로 보아, dept_emp 테이블을 읽어 파생 테이블을 생성한다.<li>id가 1번으로 같은 두 개의 테이블 <code class="language-plaintext highlighter-rouge">&lt;derived2&gt;</code>, e는 조인됐다는 것을 알 수 있다.<ul><li><code class="language-plaintext highlighter-rouge">&lt;derived2&gt;</code>가 e보다 먼저 표시됐기 때문에, <code class="language-plaintext highlighter-rouge">&lt;derived2&gt;</code>가 드라이빙 테이블, e가 드리븐 테이블이 된다.<li>즉, <code class="language-plaintext highlighter-rouge">&lt;derived2&gt;</code> 테이블을 먼저 읽고 이 결과를 기준으로 e와 조인을 한다.</ul></ol><h1 id="type-컬럼">type 컬럼</h1><hr /><blockquote><p>type 컬럼과 그 이후의 컬럼들은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 나타낸다. 즉, 인덱스를 사용해 읽었는지, 풀 테이블 스캔으로 읽었는지 등을 의미한다. 일반적으로 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하기 때문에, type 컬럼은 반드시 체크해야 할 중요한 정보이다.</p></blockquote><p><br /> 이제 type 컬럼에서 나타날 수 있는 값들에 대해 살펴보자.</p><h2 id="system">system</h2><ul><li>레코드가 1건 이하인 테이블을 참조하는 형태의 접근 방법이다.<li>MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법이다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tb_dual</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>tb_dual<td>system<td> <td> <td> <td>1<td> </table></div><h2 id="const">const</h2><ul><li>쿼리가 프라이머리 키나 유니크 키 컬럼을 이용하는 <code class="language-plaintext highlighter-rouge">WHERE</code> 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식이다.<li>쿼리의 해당 값은 옵티마이저에 의해 상수(const)화된 다음 쿼리 실행기로 전달된다.<li>다른 DBMS에서는 ‘UNIQUE INDEX SCAN’이라고도 표현한다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="k">WHERE</span> <span class="n">emp_no</span><span class="o">=</span><span class="mi">10001</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>employees<td>const<td>PRIMARY<td>4<td>const<td>1<td> </table></div><ul><li>다중 컬럼으로 구성된 프라이머리 키, 유니크 키 중에서 인덱스의 일부 컬럼만 조건으로 사용할 때는 const 타입의 접근 방법을 사용할 수 없다.</ul><h2 id="eq_ref">eq_ref</h2><ul><li>조인에서 처음 읽은 테이블의 컬럼 값을 그다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용하는 경우이다.<li>다중 컬럼으로 만들어진 프라이머리 키나 유니크 인덱스라면 인덱스의 모든 컬럼이 비교 조건에 사용돼야만 eq_ref 접근 방법이 사용될 수 있다.<ul><li>즉, 조인에서 두 번째 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야한다.</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="n">de</span><span class="p">,</span> <span class="n">employees</span> <span class="n">e</span>
<span class="k">WHERE</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="o">=</span><span class="n">de</span><span class="p">.</span><span class="n">emp_no</span> <span class="k">AND</span> <span class="n">de</span><span class="p">.</span><span class="n">dept_no</span><span class="o">=</span><span class="s1">'d005'</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>de<td>ref<td>PRIMARY<td>12<td>const<td>53288<td>Using<br />where<tr><td>1<td>SIMPLE<td>e<td>eq_ref<td>PRIMARY<td>4<td>employees.de.emp_no<td>1<td> </table></div><h2 id="ref">ref</h2><ul><li>인덱스의 종류와 관계없이 동등 조건으로 검색할 때 ref 접근 방법이 사용된다.<li>eq_ref와는 달리 조인의 순서와 관계없이 사용된다.<li>프라이머리 키나 유니크 키 등의 제약 조건도 없다.<li>반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다는 빠르지 않다.<li>const, eq_ref, ref 모두 인덱스의 분포도가 나쁘지 않다면 성능 문제를 일으키지 않는 좋은 접근 방법이다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">dept_no</span><span class="o">=</span><span class="s1">'d005'</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>dept_emp<td>ref<td>PRIMARY<td>12<td>const<td>53288<td>Using<br />where</table></div><h2 id="fulltext">fulltext</h2><ul><li>MySQL의 전문 검색(Fulltext) 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다.<li>전문 검색 인덱스는 통계 정보가 관리되지 않는다.<ul><li>따라서, 옵티마이저는 전문 인덱스를 사용할 수 있는 쿼리에서는 비용과는 관계 없이 거의 fulltext 접근 방법을 사용한다.<li>물론, 성능상 더 빠른 const, eq_ref, ref 접근 방법을 사용할 수 있는 경우에는 굳이 fulltext를 사용하지 않는다.</ul><li>전문 검색은 <code class="language-plaintext highlighter-rouge">MATCH .. AGAINST ...</code> 구문을 사용해서 실행하며, 반드시 해당 테이블에 전문 검색용 인덱스가 준비돼 있어야 한다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">employee_name</span> <span class="k">WHERE</span> <span class="n">emp_no</span><span class="o">=</span><span class="mi">10001</span>
    <span class="k">AND</span> <span class="n">emp_no</span> <span class="k">BETWEEN</span> <span class="mi">10001</span> <span class="k">AND</span> <span class="mi">10005</span>
    <span class="k">AND</span> <span class="k">MATCH</span><span class="p">(</span><span class="n">first_name</span><span class="p">,</span> <span class="n">last_name</span><span class="p">)</span> <span class="n">AGAINST</span><span class="p">(</span><span class="s1">'Facello'</span> <span class="k">IN</span> <span class="nb">BOOLEAN</span> <span class="k">MODE</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="ref_or_null">ref_or_null</h2><ul><li>ref 접근 방식과 같은데, NULL 비교가 추가된 형태다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">titles</span>
<span class="k">WHERE</span> <span class="n">to_date</span><span class="o">=</span><span class="s1">'1985-03-01'</span> <span class="k">OR</span> <span class="n">to_date</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>titles<td>ref_or_null<td>ix_todate<td>4<td>const<td>2<td>Using where;<br />Using index</table></div><h2 id="unique_subquery">unique_subquery</h2><ul><li><code class="language-plaintext highlighter-rouge">WHERE</code> 조건절에서 사용될 수 있는 <code class="language-plaintext highlighter-rouge">IN</code> (subquery) 형태의 쿼리를 위한 접근 방식이다.<li>서브 쿼리에서 중복되지 않은 유니크한 값만 반환할 때 사용한다.<li>아래 쿼리의 경우, dept_emp 테이블의 프라이머리 키가 (dept_no, emp_no)이므로 <code class="language-plaintext highlighter-rouge">emp_no=10001</code>인 레코드 중에서 dept_no는 중복이 없다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">departments</span> <span class="k">WHERE</span> <span class="n">dept_no</span> <span class="k">IN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">dept_no</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">emp_no</span><span class="o">=</span><span class="mi">10001</span><span class="p">);</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td>departments<td>index<td>PRIMARY<td>123<td> <td>9<td>Using index;<br />Using where<tr><td>2<td>DEPENDENT<br />SUBQUERY<td>dept_emp<td>unique_subquery<td>PRIMARY<td>16<td>func,const<td>1<td>Using index;<br />Using where</table></div><h2 id="index_subquery">index_subquery</h2><ul><li>IN (subquery)에서 서브 쿼리가 중복된 값을 반환할 수는 있지만 중복된 값을 인덱스를 이용해 제거할 수 있을 때 이 접근 방법이 사용된다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">departments</span> <span class="k">WHERE</span> <span class="n">dept_no</span> <span class="k">IN</span> <span class="p">(</span>
    <span class="k">SELECT</span> <span class="n">dept_no</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">dept_no</span> <span class="k">BETWEEN</span> <span class="s1">'d001'</span> <span class="k">AND</span> <span class="s1">'d003'</span><span class="p">);</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td>departments<td>index<td>ux_deptname<td>122<td> <td>9<td>Using where;<br />Using index<tr><td>2<td>DEPENDENT<br />SUBQUERY<td>dept_emp<td>index_subquery<td>PRIMARY<td>12<td>func<td>18626<td>Using index;<br />Using where</table></div><h2 id="range">range</h2><ul><li>인덱스 레인지 스캔 형태의 접근 방법이다.<li>인덱스를 하나의 값이 아닌 범위로 검색하는 경우이다.<ul><li><code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">IS NULL</code>, <code class="language-plaintext highlighter-rouge">BETWEEN</code>, <code class="language-plaintext highlighter-rouge">IN</code>, <code class="language-plaintext highlighter-rouge">LIKE</code> 등의 연산자를 이용해 검색하는 경우</ul><li>일반적으로, const, ref, range 세 가지 접근 방법을 모두 ‘인덱스 레인지 스캔’ 방식이라고 한다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="n">dept_no</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">dept_no</span> <span class="k">BETWEEN</span> <span class="s1">'d001'</span> <span class="k">AND</span> <span class="s1">'d003'</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>dept_emp<td>range<td>PRIMARY<td>12<td> <td>121890<td>Using where;<br />Using index</table></div><h2 id="index_merge">index_merge</h2><ul><li>유일하게 2개 이상의 인덱스를 이용하는 접근 방식이다.<li>각각의 인덱스를 이용해 검색 결과를 만들어낸 후 그 결과를 병합한다.<li>‘index_merge’ 접근 방식에는 다음과 같은 특징이 있다.<ul><li>여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방식보다는 효율성이 떨어진다.<li><code class="language-plaintext highlighter-rouge">AND</code>, <code class="language-plaintext highlighter-rouge">OR</code> 연산이 복잡하게 연결된 쿼리에서는 최적화되지 못할 때가 많다.<li>전문 검색 인덱스를 사용하는 쿼리에서는 적용되지 않는다.<li>병합된 처리 결과는 항상 2개 이상의 집합이 되기 때문에 교집합, 합집합 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span>
<span class="k">WHERE</span> <span class="n">emp_no</span> <span class="k">BETWEEN</span> <span class="mi">10001</span> <span class="k">AND</span> <span class="mi">11000</span>
    <span class="k">OR</span> <span class="n">first_name</span><span class="o">=</span><span class="s1">'Smith'</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>employees<td>index_merge<td>PRIMARY, ix_firstname<td>4,44<td> <td>1521<td>Using union(PRIMARY ,ix_firstname); <br /> Using where</table></div><h2 id="index">index</h2><ul><li>인덱스를 처음부터 끝까지 읽는 ‘인덱스 풀 스캔’ 방식을 의미한다.<li>많은 사람들이 ‘index’라는 이름 때문에 효율적이라고 오해하지만, range 접근 방식과 같이 인덱스의 필요한 부분만 읽는 것이 아니기 때문에 비효율적일 수 있다.<li>테이블을 처음부터 끝까지 읽는 ‘풀 테이블 스캔’ 방식과 비교하는 데이터 건수는 같다.<ul><li>하지만, 인덱스는 일반적으로 데이터 파일 전체 크기보다는 작아서 풀 테이블 스캔 보다는 빠르다.</ul><li>다음 조건 중, (1,2) 또는 (1,3)인 경우 index 접근 방법이 사용된다.<ol><li>range나 const 또는 ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우<li>인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우(데이터 파일 읽지 않아도 되는 경우)<li>인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우(별도의 정렬 작업 필요 없는 경우)</ol></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">departments</span>
<span class="k">ORDER</span> <span class="k">BY</span> <span class="n">dept_name</span> <span class="k">DESC</span> <span class="k">LIMIT</span> <span class="mi">10</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>departments<td>index<td>ux_firstname<td>123<td> <td>9<td>Using index</table></div><h2 id="all">ALL</h2><ul><li>테이블을 처음부터 끝까지 읽는 ‘풀 테이블 스캔’ 방식이다.<li>위에서 살펴본 모든 방법을 사용할 수 없는 경우 마지막으로 선택되는 가장 비효율적인 방법이다.<li>일반적으로 DBMS에는 이러한 풀 스캔 방식으로 인한 대량의 디스크 I/O를 유발하는 작업을 위해 <strong>Read Ahaed</strong>라는 기능을 제공한다.<ul><li>Read Ahead : 한 번에 여러 페이지를 읽어서 처리하는 기능</ul><li>쿼리를 튜닝한다는 것이 무조건 인덱스 풀 스캔이나, 테이블 풀 스캔을 사용하지 못하게 하는 것은 아니다.</ul><p><br /></p><p><strong><em>다음 파트에서는 실행 계획의 나머지 컬럼들에 대해 살펴볼 것이다.</em></strong></p><h1 id="관련-글">관련 글</h1><hr /><ul><li><a href="https://zz9z9.github.io/posts/execution-plan-part1/">MySQL 실행 계획 (1)</a><li><a href="https://zz9z9.github.io/posts/execution-plan-part3/">MySQL 실행 계획 (3)</a></ul><h1 id="참고-자료">참고 자료</h1><hr /><ul><li>이성욱, 『개발자와 DBA를 위한 Real MySQL』, 위키북스(2012), 6장</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EC%A7%80%EC%8B%9D-%EB%8D%94%ED%95%98%EA%B8%B0/'>지식 더하기</a>, <a href='/categories/%EC%9D%B4%EB%A1%A0/'>이론</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/mysql/" class="post-tag no-text-decoration" >MySQL</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MySQL - MySQL 실행 계획 (2) - zz9z9&url=https://zz9z9.github.io/posts/execution-plan-part2/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MySQL - MySQL 실행 계획 (2) - zz9z9&u=https://zz9z9.github.io/posts/execution-plan-part2/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=MySQL - MySQL 실행 계획 (2) - zz9z9&url=https://zz9z9.github.io/posts/execution-plan-part2/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/jpa-entity-manager-persistence-context/">EntityManager와 영속성 컨텍스트</a><li><a href="/posts/jpa-id-generation-strategy/">JPA/Hibernate ID 생성 전략</a><li><a href="/posts/aws-vpc/">AWS VPC(Virtual Private Cloud) - 기초 개념</a><li><a href="/posts/aws-efs/">AWS EFS(Elastic File System) - 기초 개념</a><li><a href="/posts/aws-intro/">AWS - 상품 살펴보기</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/web/">WEB</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/hibernate/">Hibernate</a> <a class="post-tag" href="/tags/http/">HTTP</a> <a class="post-tag" href="/tags/spring-batch/">Spring Batch</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/transaction-and-isolation-level/"><div class="card-body"> <span class="timeago small" > Aug 24, 2021 <i class="unloaded">2021-08-24T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL - 트랜잭션과 격리 수준</h3><div class="text-muted small"><p> 트랜잭션과 ACID 트랜잭션이란 ? 데이터베이스 상태를 변경시키는 일련의 연산들을 논리적으로 묶을 수 있는 하나의 작업 단위 ex) 주문 - 결제 - 결제 승인 - 주문 접수 트랜잭션에는 중요한 두 가지 목적이 있다. ...</p></div></div></a></div><div class="card"> <a href="/posts/data-modeling/"><div class="card-body"> <span class="timeago small" > Aug 25, 2021 <i class="unloaded">2021-08-25T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL - 데이터 모델링</h3><div class="text-muted small"><p> 들어가기 전 애플리케이션을 설계할 때 ‘DB 테이블은 어떻게 구성해야하지?’ 에 대한 막막함이 있다면 데이터 모델링이 문제 해결의 출발점이라고 생각한다. 공부를 하기에 앞서 나의 언어로 정리해본다면 내가 생각하기에 모델링이라는 것은 먼저 문자 그대로 ‘모델화’ 시킨다는 것인데, 모델이란 ‘어떤 대상을 필요한 특징만 추려서 나타낸 것’ 이라는 생...</p></div></div></a></div><div class="card"> <a href="/posts/mysql-architecture/"><div class="card-body"> <span class="timeago small" > Oct 6, 2021 <i class="unloaded">2021-10-06T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL - MySQL 내부 구조 간단히 살펴보기</h3><div class="text-muted small"><p> 들어가기 전 슬로우 쿼리를 고쳐보고 싶은데 고치려면 어떻게 해야할지에 대한 지식이 전혀없다. 근데 슬로우 쿼리는 차치하고, 쿼리가 어떻게 동작하고 DB 내부는 어떻게 생긴지에 대해서도 공부해보지 않았다. 그래서 먼저 MySQL을 기준으로 내부 구조가 어떤지 세부적인 내용을 제외하고 간단하게 정리해보려고 한다. MySQL의 전체적인 구조 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/execution-plan-part1/" class="btn btn-outline-primary" prompt="Older"><p>MySQL - MySQL 실행 계획 (1)</p></a> <a href="/posts/execution-plan-part3/" class="btn btn-outline-primary" prompt="Newer"><p>MySQL - MySQL 실행 계획 (3)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/username">Lee JaeYoon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/web/">WEB</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/hibernate/">Hibernate</a> <a class="post-tag" href="/tags/http/">HTTP</a> <a class="post-tag" href="/tags/spring-batch/">Spring Batch</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://zz9z9.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
