<!DOCTYPE html><html lang="en-US" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Java - 비동기 프로그래밍을 위한 자바 클래스 살펴보기" /><meta property="og:locale" content="en_US" /><meta name="description" content="들어가기 전 회사에서 화면 조회 성능 개선을 위해 어떤 부분을 리팩토링 하면될까 고민하던 중, 몇몇 화면이 호출하는 api에서 수행하는 로직이 각각 독립적인 조회 결과들을 Map에 담아 화면에 리턴해주는 형태로 되어있는 것을 보았다. 따라서, 이런 경우 비동기적으로 처리한다면 성능이 개선되지 않을까 ? 하는 생각이들어 어떤식으로 자바에서 비동기 프로그래밍을 하면되는지 공부해보았다." /><meta property="og:description" content="들어가기 전 회사에서 화면 조회 성능 개선을 위해 어떤 부분을 리팩토링 하면될까 고민하던 중, 몇몇 화면이 호출하는 api에서 수행하는 로직이 각각 독립적인 조회 결과들을 Map에 담아 화면에 리턴해주는 형태로 되어있는 것을 보았다. 따라서, 이런 경우 비동기적으로 처리한다면 성능이 개선되지 않을까 ? 하는 생각이들어 어떤식으로 자바에서 비동기 프로그래밍을 하면되는지 공부해보았다." /><link rel="canonical" href="https://zz9z9.github.io/posts/java-asyncronous-programming/" /><meta property="og:url" content="https://zz9z9.github.io/posts/java-asyncronous-programming/" /><meta property="og:site_name" content="zz9z9" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-09T00:29:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Java - 비동기 프로그래밍을 위한 자바 클래스 살펴보기" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-08-09T00:29:00+09:00","datePublished":"2021-08-09T00:29:00+09:00","description":"들어가기 전 회사에서 화면 조회 성능 개선을 위해 어떤 부분을 리팩토링 하면될까 고민하던 중, 몇몇 화면이 호출하는 api에서 수행하는 로직이 각각 독립적인 조회 결과들을 Map에 담아 화면에 리턴해주는 형태로 되어있는 것을 보았다. 따라서, 이런 경우 비동기적으로 처리한다면 성능이 개선되지 않을까 ? 하는 생각이들어 어떤식으로 자바에서 비동기 프로그래밍을 하면되는지 공부해보았다.","headline":"Java - 비동기 프로그래밍을 위한 자바 클래스 살펴보기","mainEntityOfPage":{"@type":"WebPage","@id":"https://zz9z9.github.io/posts/java-asyncronous-programming/"},"url":"https://zz9z9.github.io/posts/java-asyncronous-programming/"}</script><title>Java - 비동기 프로그래밍을 위한 자바 클래스 살펴보기 | zz9z9</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="zz9z9"><meta name="application-name" content="zz9z9"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-Q7PWLG5WYT"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Q7PWLG5WYT'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Soccerball.svg/1000px-Soccerball.svg.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">zz9z9</a></div><div class="site-subtitle font-italic">거창한 계획보다는, 꾸준한 실행을</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/zz9z9" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Java - 비동기 프로그래밍을 위한 자바 클래스 살펴보기</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Java - 비동기 프로그래밍을 위한 자바 클래스 살펴보기</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Lee JaeYoon </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Aug 9, 2021, 12:29 AM +0900" prep="on" > Aug 9, 2021 <i class="unloaded">2021-08-09T00:29:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4891 words">27 min</span></div></div><div class="post-content"><h1 id="들어가기-전">들어가기 전</h1><hr /><p>회사에서 화면 조회 성능 개선을 위해 어떤 부분을 리팩토링 하면될까 고민하던 중, 몇몇 화면이 호출하는 api에서 수행하는 로직이 각각 독립적인 조회 결과들을 Map에 담아 화면에 리턴해주는 형태로 되어있는 것을 보았다. 따라서, 이런 경우 비동기적으로 처리한다면 성능이 개선되지 않을까 ? 하는 생각이들어 어떤식으로 자바에서 비동기 프로그래밍을 하면되는지 공부해보았다.</p><h1 id="thread">Thread</h1><hr /><ul><li>자바에서 비동기 프로그래밍을 위한 첫 번째 방법은 JDK 1.0에 있는 <code class="language-plaintext highlighter-rouge">Runnable</code> 인터페이스와 <code class="language-plaintext highlighter-rouge">Thread</code> 클래스를 사용하는 것이다.<li>클래스는 <code class="language-plaintext highlighter-rouge">Runnable</code>을 구현하고 <code class="language-plaintext highlighter-rouge">run()</code> 메서드를 재정의하거나, <code class="language-plaintext highlighter-rouge">Thread</code>를 상속받아 동일한 작업을 수행할 수 있다.<ul><li>차이점은 실행 메서드가 <code class="language-plaintext highlighter-rouge">Runnable</code>에서 직접 호출될 때 새 스레드가 생성되지 않고 호출 중인 스레드에서 실행된다.<li><code class="language-plaintext highlighter-rouge">thread.start()</code>를 수행하면 새 스레드가 생성된다.</ul><li>JDK 1.5의 스레드 관리를 개선하기 위해 <code class="language-plaintext highlighter-rouge">Executor</code> 프레임워크가 등장했다. 따라서, 여러 스레드 풀을 사용할 수 있으며, 수동으로 스레드를 작성할 필요가 없다.<li><p>또한, 스레드 수를 지정할 수 있으며 스레드를 재사용할 수 있다.</p><li><a href="https://zz9z9.github.io/posts/java-threadpool-executor-framework/">이전에 공부했듯이</a>, 멀티 스레딩을 위해서는 스레드 풀을 사용하는 것이 장점이 많기 때문에 일반적으로는 비동기 처리를 위해 굳이 스레드를 직접 생성하고 관리하진 않는 것 같다.</ul><h1 id="future">Future</h1><hr /><ul><li>Java 5 부터, <code class="language-plaintext highlighter-rouge">Future</code> 인터페이스는 <code class="language-plaintext highlighter-rouge">FutureTask</code>를 사용하여 비동기 작업을 수행할 수 있는 방법을 제공한다.<li><code class="language-plaintext highlighter-rouge">ExecutorService</code>의 <code class="language-plaintext highlighter-rouge">sumbit()</code> 메서드를 사용하여 비동기적으로 작업을 수행하고 <code class="language-plaintext highlighter-rouge">FutureTask</code> 객체를 반환한다.<ul><li>이 객체는 작업이 끝나면 결과를 얻을 수 있다는 약속(promise)이며, <code class="language-plaintext highlighter-rouge">get()</code> 메서드를 사용해 결과를 얻는다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nc">ExecutorService</span> <span class="n">threadpool</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newCachedThreadPool</span><span class="o">();</span>
<span class="nc">Future</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">futureTask</span> <span class="o">=</span> <span class="n">threadpool</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">factorial</span><span class="o">(</span><span class="n">number</span><span class="o">));</span>

<span class="k">while</span> <span class="o">(!</span><span class="n">futureTask</span><span class="o">.</span><span class="na">isDone</span><span class="o">())</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"FutureTask is not finished yet..."</span><span class="o">);</span>
<span class="o">}</span>
<span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">futureTask</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>

<span class="n">threadpool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
</pre></table></code></div></div><h2 id="future의-한계">Future의 한계</h2><blockquote><p>Future API는 몇 가지 중요하고 유용한 기능이 부족하다.</p></blockquote><h3 id="1-수동으로-완료될-수-없다">1. 수동으로 완료될 수 없다.</h3><ul><li>외부 API를 호출하는 등의 과정을 거쳐 결과적으로 Future를 반환하는 메서드가 있다고 가정하자.<li>만약 API 서비스가 다운된 경우, 캐시된 가장 최근의 값 등을 Future에 세팅하여 수동으로 리턴한다면 에러가 발생하지 않을 것이다. 하지만, Future에 이러한 기능은 없다.</ul><h3 id="2-블로킹-없이-추가적인-작업을-수행할-수-없다">2. 블로킹 없이 추가적인 작업을 수행할 수 없다.</h3><ul><li>Future에 콜백 함수를 추가하고 Future의 결과를 사용할 수 있을 때, 자동으로 호출하도록 할 수 없다.<ul><li>즉, 결과를 사용할 수 있을 때까지 블로킹하는 <code class="language-plaintext highlighter-rouge">get()</code> 메서드만 제공한다.</ul></ul><h3 id="3-여러개의-작업을-병합할-수-없다">3. 여러개의 작업을 병합할 수 없다.</h3><ul><li>병렬로 실행하려는 10개의 작업이 있고 모든 작업이 완료된 후 일부 기능을 실행한다고 가정했을 때, Future에는 10개를 한꺼번에 실행할 수 있는 기능은 없다.</ul><h3 id="4-예외-처리를-제공하지-않는다">4. 예외 처리를 제공하지 않는다.</h3><ul><li>Future API에는 예외 처리를 위한 메서드 등이 없다.</ul><h1 id="completablefuture">CompletableFuture</h1><hr /><blockquote><p>위에서 살펴봤듯이 Future에는 여러가지 한계점이 있었다. 따라서, 자바8에서는 Future를 업그레이드 시킨 <code class="language-plaintext highlighter-rouge">CompletableFuture</code>가 등장했다.</p></blockquote><ul><li>CompletableFuture는 Future 뿐아니라 <code class="language-plaintext highlighter-rouge">CompletionStage</code> 인터페이스도 구현한다.<ul><li><code class="language-plaintext highlighter-rouge">CompletionStage</code>는 다른 스레드에서 계산된 결과를 간단하게 사용할 수 있는 다양한 메서드를 제공한다.<li>즉, 중첩된 콜백(callback hell) 없이 단일 결과에 여러 비동기 연산을 연결, 결합하는 파이프라인을 지원한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">priceInEur</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">getPriceInEur</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">exchangeRateEurToUsd</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">getExchangeRateEurToUsd</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">netAmountInUsd</span> <span class="o">=</span> <span class="n">priceInEur</span>
       <span class="o">.</span><span class="na">thenCombine</span><span class="o">(</span><span class="n">exchangeRateEurToUsd</span><span class="o">,</span> <span class="o">(</span><span class="n">price</span><span class="o">,</span> <span class="n">exchangeRate</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">price</span> <span class="o">*</span> <span class="n">exchangeRate</span><span class="o">);</span>

<span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"this task started"</span><span class="o">);</span>

<span class="n">netAmountInUsd</span>
       <span class="o">.</span><span class="na">thenCompose</span><span class="o">(</span><span class="n">amount</span> <span class="o">-&gt;</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">amount</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">getTax</span><span class="o">(</span><span class="n">amount</span><span class="o">))))</span>
       <span class="o">.</span><span class="na">whenComplete</span><span class="o">((</span><span class="n">grossAmountInUsd</span><span class="o">,</span> <span class="n">throwable</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">throwable</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"this task finished: {}"</span><span class="o">,</span> <span class="n">grossAmountInUsd</span><span class="o">);</span>
           <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
               <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"this task failed: {}"</span><span class="o">,</span> <span class="n">throwable</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
           <span class="o">}</span>
       <span class="o">});</span> <span class="c1">// non-blocking</span>

<span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"another task started"</span><span class="o">);</span>
</pre></table></code></div></div><li>내부적으로 <code class="language-plaintext highlighter-rouge">ForkJoinPool</code>을 사용하여 작업을 비동기식으로 처리한다.<ul><li>즉, 전역 <code class="language-plaintext highlighter-rouge">ForkJoinPool.commonPool()</code>메서드에서 얻은 스레드에서 작업을 실행한다.<ul><li><code class="language-plaintext highlighter-rouge">ForkJoinPool.commonPool()</code> 메서드에 의해 반환된 스레드 풀은 모든 CompletableFutures 및 모든 병렬 스트림에 의해 JVM 전체에서 공유된다.<li><strong><em>전역적으로 공유되기 때문에 common pool 사용시 주의해야 한다.(<a href="https://multifrontgarden.tistory.com/254">실제 장애 사례</a>)</em></strong><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Executor</span> <span class="no">ASYNC_POOL</span> <span class="o">=</span> <span class="no">USE_COMMON_POOL</span> <span class="o">?</span>
  <span class="nc">ForkJoinPool</span><span class="o">.</span><span class="na">commonPool</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="nc">ThreadPerTaskExecutor</span><span class="o">();</span>
</pre></table></code></div></div></ul><li>사용자가 스레드 풀을 명시적으로 생성하여 해당 스레드 풀에서 가져온 스레드로 작업을 처리할 수도 있다.<ul><li>즉, CompletableFuture의 여러 메소드에는 두 가지 변형이 있다.<li>하나는 사용자가 생성한 스레드 풀을 사용하고, 다른 하나는 내부적으로 생성된 스레드 풀을 사용한다.<div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">supplyAsync</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">asyncSupplyStage</span><span class="o">(</span><span class="no">ASYNC_POOL</span><span class="o">,</span> <span class="n">supplier</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="nf">supplyAsync</span><span class="o">(</span><span class="nc">Supplier</span><span class="o">&lt;</span><span class="no">U</span><span class="o">&gt;</span> <span class="n">supplier</span><span class="o">,</span>
                                                 <span class="nc">Executor</span> <span class="n">executor</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">asyncSupplyStage</span><span class="o">(</span><span class="n">screenExecutor</span><span class="o">(</span><span class="n">executor</span><span class="o">),</span> <span class="n">supplier</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">completableFuture</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">factorial</span><span class="o">(</span><span class="n">number</span><span class="o">));</span>
<span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">completableFuture</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</pre></table></code></div></div></ul></ul></ul><h2 id="completablefuture-메서드-살펴보기">CompletableFuture 메서드 살펴보기</h2><ul><li>CompletableFuture 메서드는 크게 5개 그룹으로 나뉠 수 있다.<ol><li>CompletableFuture 생성<li>작업 완료 상태 체크<li>작업 완료 시키기<li>처리 결과 읽기<li>여러개의 작업 처리(bulk futures)</ol></ul><figure align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/64415489/129049955-86ef5769-1123-4d66-9084-54e49acdf089.png" /><figcaption align="center">출처 : <a href="https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh" target="_blank"> https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh</a></figcaption></figure><h3 id="1-completablefuture-생성-메서드">1. CompletableFuture 생성 메서드</h3><ul><li>일반적으로 한 스레드에서 완료되지 않은 Future가 생성되고 다른 스레드에서 완료된다. 그러나 경우에 따라 이미 완료된 Future를 만들 수도 있다.<li>파라미터가 없는 CompletableFuture 생성자는 완료되지 않은 Future를 생성한다.</ul><figure align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/64415489/129054187-7dc96c1e-176e-4725-a603-5925f3d0741b.png" /><figcaption align="center">출처 : <a href="https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh" target="_blank"> https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh</a></figcaption></figure><h3 id="2-완료-상태-체크-메서드">2. 완료 상태 체크 메서드</h3><ul><li>CompletableFuture 클래스에는 작업이 완료되지 않았는지, 정상적으로 완료되었는지, 예외적으로 완료되었는지, 취소되었는지 여부를 확인하기 위한 non-blocking 메서드가 있다.<li>이미 완료된 작업은 취소가 불가능하다.</ul><figure align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/64415489/129054317-6e046a0b-d7ae-48cc-98fa-018a4a0e93ca.png" /><figcaption align="center">출처 : <a href="https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh" target="_blank"> https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh</a></figcaption></figure><h3 id="3-작업-완료를-위한-메서드">3. 작업 완료를 위한 메서드</h3><ul><li>CompletableFuture에는 아직 완료되지 않은 작업을 정상완료, 예외완료, 취소 상태를 갖는 완료된 작업으로 바꾸는 메서드가 있다.<li>cancel 메서드가 호출되면 <code class="language-plaintext highlighter-rouge">CancellationException</code>과 함께 연산이 취소된다. 하지만, 해당 작업을 수행하는 스레드를 중단하기 위한 <code class="language-plaintext highlighter-rouge">Thread.interrupt()</code>는 호출되지 않는다.</ul><figure align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/64415489/129054544-907049d6-a9e1-424d-94b4-090214f735e1.png" /><figcaption align="center">출처 : <a href="https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh" target="_blank"> https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh</a></figcaption></figure><h3 id="4-처리-결과-읽기-메서드">4. 처리 결과 읽기 메서드</h3><ul><li>CompletableFuture는 작업에 대한 결과를 읽는(아직 완료되지 않은 경우는 대기) 메서드를 제공한다.<li>이러한 메서드는 대부분의 경우, 계산 파이프라인의 마지막 단계로 사용해야 한다.<li><code class="language-plaintext highlighter-rouge">get()</code>, <code class="language-plaintext highlighter-rouge">get(timeout, timeUnit)</code> 메서드는 ‘checked exception’을 발생시킬 수 있다.<ul><li><code class="language-plaintext highlighter-rouge">ExecutionException</code> : 작업이 예외적으로 완료된 경우<li><code class="language-plaintext highlighter-rouge">InterruptedException</code> : 현재 스레드가 중단된 경우<li><code class="language-plaintext highlighter-rouge">TimeoutException</code> : <code class="language-plaintext highlighter-rouge">get(timeout, timeUnit)</code> 메서드 사용시 타임아웃 발생하는 경우</ul><li><code class="language-plaintext highlighter-rouge">join()</code>, <code class="language-plaintext highlighter-rouge">getNow(valueIfAbsent)</code> 메서드는 ‘unchecked exception’을 발생시킬 수 있다.<ul><li><code class="language-plaintext highlighter-rouge">CompletionException</code> : 작업이 예외적으로 완료되는 경우</ul><li>작업이 취소되는 경우, 모든 메서드가 <code class="language-plaintext highlighter-rouge">CancellationException</code>(unchecked exception)을 발생시킬 수 있다.</ul><figure align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/64415489/129055474-a98868dc-6faf-4ef8-a918-61382d94fbe7.png" /><figcaption align="center">출처 : <a href="https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh" target="_blank"> https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh</a></figcaption></figure><h3 id="5-여러개의-작업-처리를-위한-메서드">5. 여러개의 작업 처리를 위한 메서드</h3><ul><li>CompletableFuture에는 많은 작업이 완료될 때까지 대기하는 두 가지 정적 메서드가 있다.<li>각각 다른 타입의 CompletableFuture가 메서드 파라미터로 입력될 수 있다.<ul><li>정의된 파라미터 : <code class="language-plaintext highlighter-rouge">CompletableFuture&lt;?&gt;... cfs</code></ul></ul><figure align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/64415489/129055651-d4c2c46d-b8ac-4f70-b481-02c22bd68c57.png" /><figcaption align="center">출처 : <a href="https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh" target="_blank"> https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh</a></figcaption></figure><h2 id="completionstage">CompletionStage</h2><ul><li>CompletionStage 인터페이스는 여러 단계를 거치는 연산에서, fork, chain, join할 수 있는 각 단계를 나타낸다.<li>또한, future/promise 구현에 대한 파이프라이닝을 명시한다.<li>파이프라이닝<ul><li>각 단계는 연산을 수행한다. 값을 계산하거나(결과 반환) 작업 수행만 할 수도 있다(결과 반환 안 함).<li>각 단계를 파이프라인으로 연결한다.<ul><li>하나 또는 두 개의 이전 단계를 완료하여 현재 단계를 시작할 수 있다.<li>각 단계는 연산이 완료되면 종료된다.</ul><li>각 단계는 동기식 또는 비동기식으로 실행될 수 있다. 처리될 데이터에 따라 적절한 방법을 선택해야 한다.</ul><li>CompletionStage 인터페이스의 메서드는 크 두 그룹으로 나눌 수 있다.<ol><li>파이프라이닝 연산을 위한 메서드<li>예외 처리를 위한 메서드</ol></ul><figure align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/64415489/129051294-111163be-2dfb-4d52-854c-c0c864d24158.png" /><figcaption align="center">출처 : <a href="https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh" target="_blank"> https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh</a></figcaption></figure><h3 id="1-파이프라이닝-연산을-위한-메서드">1. 파이프라이닝 연산을 위한 메서드</h3><blockquote><p>CompletionStage 인터페이스에는 43개의 public 메서드가 있으며, 대부분 세 가지의 이름 패턴을 갖는다.</p></blockquote><h4 id="첫째-새로운-단계가-시작되는-방법을-설명한다">첫째, 새로운 단계가 시작되는 방법을 설명한다.</h4><ul><li>메서드 이름에 “then”이 있으면, 하나의 이전 단계가 완료된 후 새 단계가 시작된다.<li>메서드 이름에 “either”가 있으면, 이전 두 단계 중 첫 번째 단계가 완료된 후 새 단계가 시작된다.<li>메서드 이름에 “both”가 있으면, 이전 두 단계를 모두 완료한 후 새 단계가 시작된다.</ul><h4 id="둘째-새로운-단계가-수행하는-연산에-대해-설명한다">둘째, 새로운 단계가 수행하는 연산에 대해 설명한다.</h4><ul><li>메서드 이름에 “apply”가 있으면, 새로운 단계는 주어진 <code class="language-plaintext highlighter-rouge">Function</code>을 기준으로 인수를 변환한다.<li>메서드 이름에 “accept”가 있으면, 새로운 단계는 주어진 <code class="language-plaintext highlighter-rouge">Consumer</code>를 기준으로 인수를 처리한다.<li>메서드 이름에 “run”이 있으면, 새로운 단계는 주어진 <code class="language-plaintext highlighter-rouge">Runnable</code>를 기준으로 작업을 수행한다.</ul><figure align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/64415489/129068414-9ae5e35f-e54e-4a3b-9fdb-1e470209f3d9.png" /><figcaption align="center">출처 : <a href="https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh" target="_blank"> https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh</a></figcaption></figure><h4 id="셋째-어떤-스레드가-새로운-단계를-실행하는지-설명한다">셋째, 어떤 스레드가 새로운 단계를 실행하는지 설명한다.</h4><ul><li>메서드에 “something(…)”의 형태이면, 새 단계는 기본 스레드 풀에 의해 실행된다.(동기 또는 비동기)<li>메서드에 “somethingAsync()”의 형태이면, 새 단계는 기본 비동기 스레드 풀(ForkJoinPool)에 의해 실행된다.<li>메서드에 “somethingAsync(…, Executor))”의 형태이면,새 단계는지정된 Executor(사용자 정의 스레드 풀)에 의해 실행된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Double</span><span class="o">&gt;</span> <span class="n">pi</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="nc">Math</span><span class="o">.</span><span class="na">PI</span><span class="o">);</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">radius</span> <span class="o">=</span> <span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">);</span>

<span class="c1">// area of a circle = π * r^2</span>
<span class="nc">CompletableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">area</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">r</span> <span class="o">*</span> <span class="n">r</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenCombine</span><span class="o">(</span><span class="n">pi</span><span class="o">,</span> <span class="o">(</span><span class="n">multiplier1</span><span class="o">,</span> <span class="n">multiplier2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">multiplier1</span> <span class="o">*</span> <span class="n">multiplier2</span><span class="o">)</span>
        <span class="o">.</span><span class="na">thenAccept</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"area: {}"</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span>
        <span class="o">.</span><span class="na">thenRun</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"operation completed"</span><span class="o">));</span>

<span class="n">area</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
</pre></table></code></div></div><h3 id="2-예외-처리를-위한-메서드">2. 예외 처리를 위한 메서드</h3><blockquote><p>각 단계별 연산은 정상적으로 또는 예외적으로 완료될 수 있다. 또한, 비동기 연산에서는 예외가 발생한 곳과 예외 처리를 위한 메서드는 서로 다른 스레드에 있을 수 있다. 따라서 이 경우 try-catch-finally 문을 사용하여 예외를 처리할 수 없기 때문에 CompletionStage는 예외를 처리하기 위한 특별한 메서드를 제공한다.</p></blockquote><ul><li>이전 단계가 정상적으로 완료되면, 다음 단계가 정상적으로 실행되기 시작합니다.<li>이전 단계가 예외적으로 완료되면, 파이프라인에 예외 복구 단계가 없는 한 다음 단계는 예외적으로 완료된다.<li><code class="language-plaintext highlighter-rouge">whenComplete</code> 메서드를 사용하면 결과(없는 경우 null)와 예외(없는 경우 null)를 모두 읽을 수 있지만 결과를 변경할 수는 없습니다.<li>예외 발생시 복구해야 하는 경우 <code class="language-plaintext highlighter-rouge">handle</code>과 <code class="language-plaintext highlighter-rouge">exceptionally</code> 메서드를 사용한다.<ul><li><code class="language-plaintext highlighter-rouge">handle</code> 메소드의 <code class="language-plaintext highlighter-rouge">BiFunction</code> 인수는 이전 단계가 정상적으로 또는 예외적으로 완료될 때 모두 호출된다.<li><code class="language-plaintext highlighter-rouge">exceptionally</code> 메서드의 <code class="language-plaintext highlighter-rouge">Function</code> 인수는 이전 단계가 예외적으로 완료될 때 호출된다.<li>두 경우 모두 예외가 다음 단계로 전파되지 않는다.</ul></ul><figure align="center"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/64415489/129049131-389e06b3-b558-4e28-a7fc-f8a0ac09d786.png" /><figcaption align="center">출처 : <a href="https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh" target="_blank"> https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh</a></figcaption></figure><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="nc">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">)</span>
       <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"stage 1: {}"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">i</span><span class="o">;</span> <span class="o">})</span> <span class="c1">// executed and failed</span>
       <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"stage 2: {}"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">i</span><span class="o">;</span> <span class="o">})</span> <span class="c1">// skipped</span>
       <span class="o">.</span><span class="na">whenComplete</span><span class="o">((</span><span class="n">value</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"success: {}"</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
           <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
               <span class="n">logger</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">"failure: {}"</span><span class="o">,</span> <span class="n">t</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span> <span class="c1">// executed</span>
           <span class="o">}</span>
       <span class="o">})</span>
       <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"stage 3: {}"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">i</span><span class="o">;</span> <span class="o">})</span> <span class="c1">// skipped</span>
       <span class="o">.</span><span class="na">handle</span><span class="o">((</span><span class="n">value</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
           <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
               <span class="k">return</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
           <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
               <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// executed and recovered</span>
           <span class="o">}</span>
       <span class="o">})</span>
       <span class="o">.</span><span class="na">thenApply</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"stage 4: {}"</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">i</span><span class="o">;</span> <span class="o">})</span> <span class="c1">// executed</span>
       <span class="o">.</span><span class="na">join</span><span class="o">();</span>
</pre></table></code></div></div><h2 id="completablefuture-사용시-주의사항">CompletableFuture 사용시 주의사항</h2><ul><li>어떤 스레드가 어떤 단계를 실행하는지 알고, 되도록이면 우선 순위가 높은 스레드가 오래 실행되는 낮은 우선 순위의 작업을 처리하지 않게 한다.<li>파이프라인 내에서 블로킹 메서드 사용을 지양한다.<li>빈번한 context switch로 인해 상당한 오버헤드가 발생할 수 있으므로 짧은(수백 밀리초) 비동기식 계산을 지양한다.<li>try-catch-finally 문과 다르게 작동하는 새로운 예외 처리 메커니즘에 유의할 것.<li>작업이 완료되는 것을 너무 오래 기다리지 않도록 타임아웃을 관리한다.</ul><h1 id="parallel-stream">Parallel Stream</h1><hr /><ul><li>Fork-Join Framework를 이용하여 작업들을 분할하고, 병렬적으로 처리한다.<ul><li>Fork-Join Framework는 작업 데이터를 worker 스레드 간에 분할하고, 작업 완료 시 콜백 처리를 담당한다.</ul><li>공통 풀의 스레드 수는 프로세서 코어 수(논리 코어 수, <code class="language-plaintext highlighter-rouge">Runtime.getRuntime().availableProcessors()</code>)와 동일하다. 그러나 JVM 매개 변수를 전달하여 사용할 스레드 수를 지정할 수도 있다.<ul><li><code class="language-plaintext highlighter-rouge">-D java.util.concurrent.ForkJoinPool.common.parallelism=4</code><li>그러나 이 설정은 전역 설정이므로 모든 병렬 스트림과 공통 풀을 사용하는 fork-join 작업에 영향을 미치기 때문에, 합당한 이유가 아닌 이상 기본 설정을 사용하는 것을 권장한다.<li><strong><em>전역적으로 공유되기 때문에 common pool 사용시 주의해야 한다.(<a href="https://multifrontgarden.tistory.com/254">실제 장애 사례</a>)</em></strong></ul></ul><p><br /> <em>병렬 처리의 이점을 완벽히 활용하려면, 다음과 같은 오버헤드를 고려해야한다.</em></p><h2 id="splitting-costs분할-비용">Splitting Costs(분할 비용)</h2><blockquote><p>데이터 소스를 고르게 분할하는 데 드는 비용이다. 즉, Parallel Stream은 작업을 분할하기 위해 <code class="language-plaintext highlighter-rouge">Spliterator</code>의 <code class="language-plaintext highlighter-rouge">trySplit()</code>을 사용하는데, 분할되는 작업의 단위가 균등하게 나누어져야 하며, 나누어지는 작업에 대한 비용이 높지 않아야 순차적 방식보다 효율적으로 이루어질 수 있다.</p></blockquote><ul><li>0 ~ 1,000,000까지 ArrayList와 LinkedList에 할당한 뒤, 일반 스트림과 병렬 스트림 사용하여 성능 비교<ul><li>ArrayList는 위치 속성을 활용하여 저렴하고 고르게 분할할 수 있는 반면, LinkedList에는 이러한 속성이 없다.<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Benchmark                                                     Mode  Cnt        Score        Error     Units
DifferentSourceSplitting.differentSourceArrayListParallel     avgt   25    2004849,711 ±    5289,437  ns/op
DifferentSourceSplitting.differentSourceArrayListSequential   avgt   25    5437923,224 ±   37398,940  ns/op
DifferentSourceSplitting.differentSourceLinkedListParallel    avgt   25   13561609,611 ±  275658,633  ns/op
DifferentSourceSplitting.differentSourceLinkedListSequential  avgt   25   10664918,132 ±  254251,184  ns/op
</pre></table></code></div></div></ul></ul><h2 id="merging-costs병합-비용">Merging Costs(병합 비용)</h2><ul><li>병렬 연산을 위해 분할한 데이터 소스를 처리하고 난 뒤에는 각각의 결과를 병합해야 한다.<li>다음은 0 ~ 1,000,000까지 ArrayList에 할당한 뒤 <code class="language-plaintext highlighter-rouge">reduce()</code>를 통해 병합하는 경우와, <code class="language-plaintext highlighter-rouge">collect()</code>를 통해 <code class="language-plaintext highlighter-rouge">Set</code>으로 그룹화하는 경우에 대한 성능비교이다.<ul><li>reduce 같은 연산의 경우 비용이 저렴한 반면, <code class="language-plaintext highlighter-rouge">Set</code>이나 <code class="language-plaintext highlighter-rouge">Map</code>에 그룹화하는 것과 같은 병합 작업은 상당한 비용이 들 수 있다.<div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Benchmark                                                     Mode  Cnt        Score        Error     Units
MergingCosts.mergingCostsGroupingParallel                     avgt   25  135093312,675 ± 4195024,803  ns/op
MergingCosts.mergingCostsGroupingSequential                   avgt   25   70631711,489 ± 1517217,320  ns/op
MergingCosts.mergingCostsSumParallel                          avgt   25    2074483,821 ±    7520,402  ns/op
MergingCosts.mergingCostsSumSequential                        avgt   25    5509573,621 ±   60249,942  ns/op
</pre></table></code></div></div></ul></ul><h2 id="독립적인-작업">독립적인 작업</h2><ul><li><code class="language-plaintext highlighter-rouge">distinct()</code>, <code class="language-plaintext highlighter-rouge">sorted()</code>와 같은 중간 단계 연산들(intermediate operation) 중 일부 연산자들은 연산자 내부에 상태(State) 정보를 가지고 있다.<li>따라서, 모든 Worker들은 독립적으로 다른 Thread에 의해 실행되지만 처리 결과를 이런 상태 정보에 저장하고, distinct() 연산자는 이 정보를 이용하여 정해진 기능을 수행한다.<li>즉, 내부적으로 어떤 공용 변수를 만들어 놓고 각 worker들이 이 변수에 접근할 경우 동기화 작업(synchronized) 등을 통해 변수를 안전하게 유지하면서 처리하고 있다.<li>따라서, 잘못 사용할 경우 순차적 실행보다 더 느릴 수도 있다.</ul><h2 id="nq-model">NQ Model</h2><ul><li>Oracle에서 제시한 간단한 모델로써, 병렬화가 성능 향상을 제공할 수 있는지 여부를 판단하는 데 도움이 될 수 있다.<li>N : 소스 데이터 요소의 수<li>Q : 데이터 요소당 수행되는 계산의 양<li>N*Q 제품이 클수록 병렬화를 통해 성능이 향상될 가능성이 높다.<li>숫자 합계와 같이 Q가 아주 작은 문제의 경우, N은 10,000보다 커야 한다.<li>계산 수가 증가함에 따라 병렬 처리로 성능을 높이는 데 필요한 데이터 크기는 감소한다.<li>좀 더 상세한 내용은 <a href="http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html">이 글</a> 을 참조하면 좋을 것 같다.</ul><h2 id="completablefuture-vs-parallel-stream">CompletableFuture vs Parallel Stream</h2><ul><li>CompletableFuture와 Parallel Stream이 동일한 fork join common pool을 사용하는 동안 성능은 비슷할 수 있다.<li>CompletableFuture의 성능은 선택한 스레드 수로 사용자 정의 스레드 풀을 구성해야 하는 상황에서 더 좋을 수 있다.<li>또한, 다른 작업을 수행하는 동안 URL에서 다운로드하려는 경우와 같이 비동기식 방법을 찾고 있다면 CompletableFuture를 선택할 수 있다.<li>Parallel Stream은 모든 작업이 일부 작업을 수행하기를 원하는 CPU 집약적 작업, 즉 모든 스레드가 다른 데이터로 동일한 작업을 수행하기를 원하는 경우 좋은 선택이 될 수 있다.</ul><h1 id="실제로-적용하기">실제로 적용하기</h1><hr /><ul><li><a href="https://zz9z9.github.io/posts/applying-java-async-for-performance/">회사 코드 비동기적으로 리팩토링 해보고 성능 비교해보기</a></ul><h1 id="더-공부해야할-부분">더 공부해야할 부분</h1><hr /><ul><li>stream 기초, 내부적인 작동방식 등</ul><h1 id="참고자료">참고자료</h1><hr /><ul><li><a href="https://www.baeldung.com/java-asynchronous-programming">https://www.baeldung.com/java-asynchronous-programming</a><li><a href="https://www.cognizantsoftvision.com/blog/async-in-java/">https://www.cognizantsoftvision.com/blog/async-in-java/</a><li><a href="https://www.linkedin.com/pulse/java-8-future-vs-completablefuture-saral-saxena">https://www.linkedin.com/pulse/java-8-future-vs-completablefuture-saral-saxena</a><li><a href="https://www.callicoder.com/java-8-completablefuture-tutorial/">https://www.callicoder.com/java-8-completablefuture-tutorial/</a><li><a href="https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh">https://www.linkedin.com/pulse/asynchronous-programming-java-completablefuture-aliaksandr-liakh</a><li><a href="https://www.baeldung.com/java-when-to-use-parallel-stream">https://www.baeldung.com/java-when-to-use-parallel-stream</a><li><a href="https://www.popit.kr/java8-stream%EC%9D%98-parallel-%EC%B2%98%EB%A6%AC/">https://www.popit.kr/java8-stream%EC%9D%98-parallel-%EC%B2%98%EB%A6%AC/</a><li><a href="https://m.blog.naver.com/tmondev/220945933678">https://m.blog.naver.com/tmondev/220945933678</a><li><a href="https://roytuts.com/difference-between-parallel-stream-and-completablefuture-in-java/">https://roytuts.com/difference-between-parallel-stream-and-completablefuture-in-java/</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EC%A7%80%EC%8B%9D-%EB%8D%94%ED%95%98%EA%B8%B0/'>지식 더하기</a>, <a href='/categories/%EC%9D%B4%EB%A1%A0/'>이론</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Java - 비동기 프로그래밍을 위한 자바 클래스 살펴보기 - zz9z9&url=https://zz9z9.github.io/posts/java-asyncronous-programming/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Java - 비동기 프로그래밍을 위한 자바 클래스 살펴보기 - zz9z9&u=https://zz9z9.github.io/posts/java-asyncronous-programming/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Java - 비동기 프로그래밍을 위한 자바 클래스 살펴보기 - zz9z9&url=https://zz9z9.github.io/posts/java-asyncronous-programming/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/jpa-entity-manager-persistence-context/">EntityManager와 영속성 컨텍스트</a><li><a href="/posts/jpa-id-generation-strategy/">JPA/Hibernate ID 생성 전략</a><li><a href="/posts/aws-vpc/">AWS VPC(Virtual Private Cloud) - 기초 개념</a><li><a href="/posts/aws-efs/">AWS EFS(Elastic File System) - 기초 개념</a><li><a href="/posts/aws-intro/">AWS - 상품 살펴보기</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/web/">WEB</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/hibernate/">Hibernate</a> <a class="post-tag" href="/tags/http/">HTTP</a> <a class="post-tag" href="/tags/spring-batch/">Spring Batch</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/java-io-nio/"><div class="card-body"> <span class="timeago small" > Sep 7, 2021 <i class="unloaded">2021-09-07T00:29:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java - 자바 IO, NIO</h3><div class="text-muted small"><p> Java I/O Input, Output을 나타낸다. In, Out의 기준은 JVM이다. 즉, JVM으로 들어오는 데이터를 다루는 경우엔 Input 데이터를 내보내는 경우엔 Output이다. Stream 기반이다. 한 번에 1byte 또는 그 이상의 byte를 읽는다. 데이터가 캐시되지 않는다. 따라서 데...</p></div></div></a></div><div class="card"> <a href="/posts/java-reading-file/"><div class="card-body"> <span class="timeago small" > Sep 8, 2021 <i class="unloaded">2021-09-08T00:29:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java - 자바에서 파일 읽어오기</h3><div class="text-muted small"><p> 들어가기 전 사실 실무에서 자바 코드로 파일을 읽어와서 데이터를 처리하거나 할 일이 없어서, 파일을 다루는 부분에 대한 코드를 작성할 일이 생기면, 그 때 마다 구글링해서 사용했던 것 같다. 최근에 .json 파일에 있는 데이터를 읽어와서 처리해야할 일이 있었는데, 매번 구글링 하는 것 보다 머릿속에 한 번 확실히 정리해야 할 것 같다는 생각이 들어...</p></div></div></a></div><div class="card"> <a href="/posts/equals-and-hashcode/"><div class="card-body"> <span class="timeago small" > Sep 24, 2021 <i class="unloaded">2021-09-24T22:25:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java - 왜 equals()와 hashCode()는 함께 오버라이딩 해야할까 ?</h3><div class="text-muted small"><p> 들어가기 전 실무에서는 equals(), hashCode() 메서드를 오버라이드 할 일이 별로 없었던 것 같다. 하지만 몇 달 전 간단한 웹 서버를 만들어보는 토이 프로젝트를 진행하던 중, 클라이언트로부터 받은 요청을 유틸 클래스의 메서드를 사용해서 HttpRequest 객체를 만드는 부분에 대한 테스트 코드를 작성했는데 원하는 결과가 나오지 않았다...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/java-threadpool-executor-framework/" class="btn btn-outline-primary" prompt="Older"><p>Java - Thread Pool을 위한 Java Executor Framework</p></a> <a href="/posts/java-exception-error/" class="btn btn-outline-primary" prompt="Newer"><p>Java - Exception과 Error</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/username">Lee JaeYoon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/web/">WEB</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/hibernate/">Hibernate</a> <a class="post-tag" href="/tags/http/">HTTP</a> <a class="post-tag" href="/tags/spring-batch/">Spring Batch</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://zz9z9.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
