<!DOCTYPE html><html lang="en-US" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="MySQL - MySQL 실행 계획 (3)" /><meta property="og:locale" content="en_US" /><meta name="description" content="들어가기 전 실행 계획을 나타내는 테이블의 다양한 컬럼들 중 possible_keys, key, key_len, ref, rows, Extra 컬럼에 대해 살펴볼 것이다. 또한 EXPLAIN 명령 이외에 EXPLAIN EXTENDED, EXPLAIN PARTITIONS 대해서도 알아보자." /><meta property="og:description" content="들어가기 전 실행 계획을 나타내는 테이블의 다양한 컬럼들 중 possible_keys, key, key_len, ref, rows, Extra 컬럼에 대해 살펴볼 것이다. 또한 EXPLAIN 명령 이외에 EXPLAIN EXTENDED, EXPLAIN PARTITIONS 대해서도 알아보자." /><link rel="canonical" href="https://zz9z9.github.io/posts/execution-plan-part3/" /><meta property="og:url" content="https://zz9z9.github.io/posts/execution-plan-part3/" /><meta property="og:site_name" content="zz9z9" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-09T23:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MySQL - MySQL 실행 계획 (3)" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-10-09T23:00:00+09:00","datePublished":"2021-10-09T23:00:00+09:00","description":"들어가기 전 실행 계획을 나타내는 테이블의 다양한 컬럼들 중 possible_keys, key, key_len, ref, rows, Extra 컬럼에 대해 살펴볼 것이다. 또한 EXPLAIN 명령 이외에 EXPLAIN EXTENDED, EXPLAIN PARTITIONS 대해서도 알아보자.","headline":"MySQL - MySQL 실행 계획 (3)","mainEntityOfPage":{"@type":"WebPage","@id":"https://zz9z9.github.io/posts/execution-plan-part3/"},"url":"https://zz9z9.github.io/posts/execution-plan-part3/"}</script><title>MySQL - MySQL 실행 계획 (3) | zz9z9</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="zz9z9"><meta name="application-name" content="zz9z9"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-Q7PWLG5WYT"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-Q7PWLG5WYT'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Soccerball.svg/1000px-Soccerball.svg.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">zz9z9</a></div><div class="site-subtitle font-italic">거창한 계획보다는, 꾸준한 실행을</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/zz9z9" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>MySQL - MySQL 실행 계획 (3)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>MySQL - MySQL 실행 계획 (3)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Lee JaeYoon </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Oct 9, 2021, 11:00 PM +0900" prep="on" > Oct 9, 2021 <i class="unloaded">2021-10-09T23:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6173 words">34 min</span></div></div><div class="post-content"><h1 id="들어가기-전">들어가기 전</h1><hr /><p>실행 계획을 나타내는 테이블의 다양한 컬럼들 중 possible_keys, key, key_len, ref, rows, Extra 컬럼에 대해 살펴볼 것이다. <br /> 또한 <code class="language-plaintext highlighter-rouge">EXPLAIN</code> 명령 이외에 <code class="language-plaintext highlighter-rouge">EXPLAIN EXTENDED</code>, <code class="language-plaintext highlighter-rouge">EXPLAIN PARTITIONS</code> 대해서도 알아보자.</p><p>※ <a href="https://zz9z9.github.io/posts/execution-plan-part1/">실행 계획 1편</a>, <a href="https://zz9z9.github.io/posts/execution-plan-part2/">실행 계획 2편</a>을 먼저 읽으실 것을 권장합니다.</p><h1 id="possible_keys-컬럼">possible_keys 컬럼</h1><hr /><blockquote><p>옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방식에서 사용되는 인덱스의 목록이다.</p></blockquote><ul><li>즉, 사용될 법했던 인덱스의 목록이다.<li>해당 테이블의 모든 인덱스가 포함되어 나오는 경우가 많기 때문에 쿼리를 튜닝하는 데 도움이 되지 않는다.</ul><h1 id="key-컬럼">key 컬럼</h1><hr /><blockquote><p>최종 선택된 실행 계획에서 사용하는 인덱스이다.</p></blockquote><ul><li>쿼리를 튜닝할 때는 key 컬럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다.<li>값이 ‘PRIMARY’인 경우에는 프라이머리 키를 사용한다는 의미이다.<ul><li>그 외에는 모두 테이블이나 인덱스를 생성할 때 부여했던 고유 이름이다.<li>테이블 풀 스캔 방식 처럼 인덱스를 사용하지 못하는 경우에는 ‘NULL’로 표시된다.<li>type 컬럼의 값이 ‘index_merge’인 경우에는 2개 이상의 값이 표시된다.</ul></ul><h1 id="key_len-컬럼">key_len 컬럼</h1><hr /><blockquote><p>단일, 다중 컬럼으로 구성된 인덱스에서 몇 개의 컬럼까지 사용했는지 알려준다. 즉, 각 레코드에서 몇 바이트까지 사용했는지를 알려주는 값이다.</p></blockquote><ul><li>dept_emp 테이블의 프라이머리 키는 dept_no, emp_no 두 개의 컬럼으로 구성되어있다.<ul><li>dept_no 컬럼의 타입은 <code class="language-plaintext highlighter-rouge">CHAR(4)</code>이며 UTF8 문자집합을 사용한다.<li>아래 쿼리는 조회시 dept_no만 사용하고 있으므로 결과적으로 key_len의 값은 12로 표시된다.<li>즉, UTF8 문자를 위한 메모리 공간은 3바이트이기 때문에 3*4=12(byte) 라는 값이 도출된다.</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">dept_no</span><span class="o">=</span><span class="s1">'d005'</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>dept_emp<td>ref<td>PRIMARY<td>12<td>const<td>53288<td>Using where</table></div><ul><li>프라이머리 키를 구성하는 두 개의 컬럼을 다 사용한 경우이다.<ul><li>emp_no 컬럼 타입은 <code class="language-plaintext highlighter-rouge">INTEGER</code>이며 4바이트를 차지한다.</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">dept_no</span><span class="o">=</span><span class="s1">'d005'</span> <span class="k">AND</span> <span class="n">emp_no</span><span class="o">=</span><span class="mi">10001</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>dept_emp<td>ref<td>PRIMARY<td>16<td>const,const<td>1<td> </table></div><h2 id="mysql-50-vs-mysql-51">MySQL 5.0 vs MySQL 5.1</h2><blockquote><p>아래와 같은 쿼리가 있을 때 MySQL 5.0 버전과 5.1 버전에서의 결과가 어떤 차이가 있는지 살펴보자. dept_emp 테이블의 프라이머리 키는 dept_no, emp_no으로 구성된다.</p></blockquote><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">dept_no</span><span class="o">=</span><span class="s1">'d005'</span> <span class="k">AND</span> <span class="n">emp_no</span> <span class="o">&lt;&gt;</span> <span class="mi">10001</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>MySQL 5.0 이하<ul><li>프라이머리 키인 dept_no, emp_no을 모두 사용했지만 key_len은 16이 아닌 12로 표시된다.<li>그 이유는 key_len에 표시되는 값은 인덱스를 이용해 범위를 제한하는 조건의 컬럼까지만 포함되기 때문이다.<li>즉, 체크 조건(<code class="language-plaintext highlighter-rouge">emp_no &lt;&gt; 10001</code>)으로 사용되는 emp_no의 경우는 key_len에 포함되지 않는다.<li>결과적으로 5.0 이하 버전에서는 key_len 컬럼의 값으로 인덱스의 몇 바이트까지가 범위 제한 조건으로 사용됐는지 판단할 수 있다.</ul></ul><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>dept_emp<td>ref<td>PRIMARY<td>12<td>const<td>53298<td>Using where</table></div><ul><li>MySQL 5.1 이상<ul><li>체크 조건에 포함되는 컬럼까지 계산된 값이 key_len에 표시된다.<li>결과적으로 인덱스의 몇 바이트까지가 범위 제한 조건으로 사용됐는지 알 수 없다.</ul></ul><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>dept_emp<td>range<td>PRIMARY<td>16<td> <td>53298<td>Using where</table></div><h2 id="컨디션-푸시-다운condition-push-down">컨디션 푸시 다운(Condition push down)</h2><blockquote><p>위에서 살펴본 차이는 버전이 올라가면서 MySQL 엔진과 InnoDB 스토리지 엔진의 역할 분담에 변화가 생겼기 때문이다.</p></blockquote><ul><li>5.0 버전까지는 범위 제한 조건으로 사용되는 컬럼만 스토리지 엔진으로 전달했다.<li>5.1 버전부터는 범위 제한 조건이든 체크 조건이든 인덱스를 이용할 수만 있다면 모두 스토리지 엔진으로 전달한다.<ul><li>이를 <strong>컨디션 푸시 다운</strong>이라고 한다.</ul></ul><h1 id="ref-컬럼">ref 컬럼</h1><hr /><blockquote><p>type 컬럼의 값(접근 방식)이 ‘ref’이면 ref 컬럼에서는 어떤 값이 제공됐는지 표시된다.</p></blockquote><ul><li>상수 값을 지정했다면 ref 컬럼의 값은 const로 표시된다.<li>다른 테이블의 컬럼이라면 그 테이블 명과 컬럼 명이 표시된다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="n">e</span><span class="p">,</span> <span class="n">dept_emp</span> <span class="n">de</span>
<span class="k">WHERE</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="o">=</span><span class="n">de</span><span class="p">.</span><span class="n">emp_no</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>de<td>ALL<td> <td> <td> <td>334868<td> <tr><td>1<td>SIMPLE<td>e<td>eq_ref<td>PRIMARY<td>4<td>de.emp_no<td>1<td> </table></div><ul><li>만약 ref 컬럼의 값이 ‘func’라면 이는 참조용으로 사용되는 값을 그대로 사용한 것이 아니라, 콜레이션 변환이나 값 자체의 연산을 거쳐서 참조됐다는 것을 의미한다.<li>사용자가 명시적으로 값을 변환할 때뿐만 아니라 MySQL 서버가 내부적으로 값을 변환해야 할 때도 ‘func’가 출력된다.<li>대표적인 경우는 다음과 같다.<ul><li>문자집합이 일치하지 않는 두 문자열 컬럼을 조인하는 경우<li>숫자 타입의 컬럼과 문자열 타입의 컬럼으로 조인하는 경우</ul><li>가능한 MySQL이 이런 변환을 하지 않아도 되도록 조인 컬럼의 타입은 일치시키는 것이 좋다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="n">e</span><span class="p">,</span> <span class="n">dept_emp</span> <span class="n">de</span>
<span class="k">WHERE</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="o">=</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">emp_no</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>de<td>ALL<td> <td> <td> <td>334868<td> <tr><td>1<td>SIMPLE<td>e<td>eq_ref<td>PRIMARY<td>4<td>func<td>1<td> </table></div><h1 id="rows-컬럼">rows 컬럼</h1><hr /><blockquote><p>실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다. 각 스토리지 엔진별로 갖고 있는 통계 정보를 참조해 옵티마이저가 산출한 예상 값이라 정확하지는 않다.</p></blockquote><ul><li>각 실행 계획의 비용을 산정하는 방법은 각 처리 방식이 얼마나 많은 레코드를 읽고 비교해야 하는지 예측해 보는 것이다.<ul><li>즉, 대상 테이블에 얼마나 많은 레코드가 포함되는지, 인덱스 값의 분포도가 어떤지를 기준으로 조사해서 예측한다.</ul><li><p>rows 컬럼에 표시되는 값은 반환하는 레코드의 예측치가 아니라, 쿼리를 처리하기 위해 얼마나 많은 레코드를 디스크로부터 읽고 체크해야 하는지를 의미한다.</p><li>아래 쿼리의 경우 ix_fromdate 인덱스를 사용할 수도 있었지만, 결과적으로는 테이블 풀 스캔(ALL) 방식을 사용한다.<ul><li>dept_emp 테이블의 전체 레코드는 331,603 건이라고 한다.<li>rows 컬럼을 보면 옵티마이저는 이 쿼리를 처리하기 위해 대략 334,868건의 레코드를 읽어야 할 것이라고 예측했다.<ul><li>즉, 옵티마이저는 전체 레코드의 대부분을 비교해봐야 한다고 판단했기 때문에 인덱스 레인지 스캔이 아닌 ‘ALL’을 선택했다.</ul></ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">from_date</span><span class="o">&gt;=</span><span class="s1">'1985-01-01'</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>possible_keys<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>dept_emp<td>ALL<td>ix_fromdate<td> <td> <td> <td>334868<td>Using<br />where</table></div><ul><li>위의 쿼리에서 범위를 좁혀보자.<ul><li>옵티마이저는 292 건의 레코드(전체 레코드의 8.8%)를 읽으면 아래 쿼리를 처리할 수 있을 것으로 예측했다.<li>따라서, 인덱스 레인지 스캔 방식을 선택했다.</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">from_date</span><span class="o">&gt;=</span><span class="s1">'2002-07-01'</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>possible_keys<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>dept_emp<td>range<td>ix_fromdate<td>ix_fromdate<td>3<td> <td>292<td>Using<br />where</table></div><h1 id="extra-컬럼">Extra 컬럼</h1><hr /><p>컬럼의 이름과 달리, 성능에 관련된 중요한 내용이 자주 표시된다. 다 알아보기엔 너무 많기 때문에 카테고리 별로 나눠서 몇 가지만 살펴보자. <br /></p><h2 id="1-쿼리가-요건을-제대로-반영하고-있는지-확인해야-하는-경우">1. 쿼리가 요건을 제대로 반영하고 있는지 확인해야 하는 경우</h2><blockquote><p>아래와 같은 코멘트가 표시된다면 쿼리가 요건을 제대로 반영해서 작성됐는지, 버그가 생길 가능성은 없는지 확인해야 한다. 즉, 아래 항목들은 “이런 레코드가 없음”이라는 의미가 강하기 때문에, 이로 인한 버그의 가능성에 대해 검토해야 한다. 한 가지 주의할 점은 ‘Impossible WHERE …’, ‘No matching …’ 등의 메시지는 쿼리의 실행 계획을 산출하기 위한 기초 자료가 없음을 표현하는 것이므로 실제 쿼리 오류가 발생한다고 생각해서는 안된다.</p></blockquote><h3 id="full-scan-on-null-key">Full scan on NULL key</h3><blockquote><p><code class="language-plaintext highlighter-rouge">col1 IN (SELECT ... FROM ...)</code>과 같은 조건에서 col1이 NULL인 경우 예비책으로 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드이다.</p></blockquote><ul><li><code class="language-plaintext highlighter-rouge">col1 IN (SELECT ... FROM ...)</code>과 같은 조건이 포함된 쿼리에서 col1이 NULL이라면?<ul><li>연산을 수행하기 위해 위 조건은 다음과 같이 비교돼야 한다.<ul><li>서브 쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 NULL<li>서브 쿼리가 1건도 결과 레코드를 가지지 않는다면 최종 비교 결과는 FALSE</ul><li>위와 같은 비교 과정은 col1이 NULL이기 때문에, 풀 테이블 스캔을 해야만 결과를 알아낼 수 있다.</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="n">d</span><span class="p">.</span><span class="n">dept_no</span><span class="p">,</span> <span class="k">NULL</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">id</span><span class="p">.</span><span class="n">dpet_name</span> <span class="k">FROM</span> <span class="n">departments</span> <span class="n">id</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">departments</span> <span class="n">d</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td>d<td>index<td>ux_deptname<td>123<td>NULL<td>9<td>Using index<tr><td>1<td>DEPENDENT<br />SUBQUERY<td>id<td>index_subquery<td>ux_deptname<td>123<td>const<td>2<td>Using index;<br />Full scan on NULL key</table></div><ul><li>만약 컬럼이 <code class="language-plaintext highlighter-rouge">NOT NULL</code>로 정의되지는 않았지만 이러한 NULL 비교 규칙을 무시해도 된다면, col1이 절대 NULL이 될 수 없다는 것을 옵티마이저에게 알려주면 된다.<li>대표적으로 다음과 같은 방법이 있다.<ul><li>col1이 NULL이면 <code class="language-plaintext highlighter-rouge">col1 IS NOT NULL</code> 조건이 FALSE가 되기 때문에 그 아래 조건은 실행하지 않는다.</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">tb_test1</span>
<span class="k">WHERE</span> <span class="n">col1</span> <span class="k">IS</span> <span class="k">NOT</span> <span class="k">NULL</span>
    <span class="k">AND</span> <span class="n">col1</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">col2</span> <span class="k">FROM</span> <span class="n">tb_test2</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="impossible-having-51-버전부터">Impossible HAVING (5.1 버전부터)</h3><blockquote><p>쿼리에 사용된 <code class="language-plaintext highlighter-rouge">HAVING</code>절의 조건을 만족하는 레코드가 없는 경우이다. 이런 경우, 쿼리가 제대로 작성되지 못한 경우가 대부분이므로 다시 검토해보는 것이 좋다.</p></blockquote><ul><li>아래 쿼리에서 emp_no 컬럼은 프라이머리 키이면서 NOT NULL 타입의 컬럼이다.<li>따라서, 절대 <code class="language-plaintext highlighter-rouge">e.emp_no IS NULL</code> 조건을 만족할 가능성이 없다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="p">,</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">AS</span> <span class="n">cnt</span>
<span class="k">FROM</span> <span class="n">employees</span> <span class="n">e</span>
<span class="k">WHERE</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="o">=</span><span class="mi">10001</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span>
<span class="k">HAVING</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td> <td> <td> <td> <td> <td> <td>Impossible HAVING</table></div><h3 id="impossible-where-51-버전부터">Impossible WHERE (5.1 버전부터)</h3><blockquote><p><code class="language-plaintext highlighter-rouge">WHERE</code> 조건이 항상 FALSE가 될 수 밖에 없는 경우이다.</p></blockquote><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="k">WHERE</span> <span class="n">emp_no</span> <span class="k">IS</span> <span class="k">NULL</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td> <td> <td> <td> <td> <td> <td>Impossible WHERE</table></div><h3 id="impossible-where-noticed-after-reading-const-tables">Impossible WHERE noticed after reading const tables</h3><blockquote><p>쿼리에서 const 접근 방식이 필요한 부분은 실행 계획 수립 단계에서 옵티마이저가 직접 쿼리의 일부를 실행하고, 실행된 결과 값을 원본 쿼리의 상수로 대체한다. 이 과정을 마친 뒤, 불가능한 조건으로 판단되는 경우이다.</p></blockquote><ul><li>아래의 경우, 실행 계획만 확인했을 뿐인데, 옵티마이저는 사번이 0번인 사원이 없다는 것까지 확인한다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="k">WHERE</span> <span class="n">emp_no</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td> <td> <td> <td> <td> <td> <td>Impossible WHERE noticed<br />after reading const tables</table></div><h3 id="no-matching-minmax-row-51-버전부터">No matching min/max row (5.1 버전부터)</h3><blockquote><p><code class="language-plaintext highlighter-rouge">MIN()</code>, <code class="language-plaintext highlighter-rouge">MAX()</code>와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없는 경우이다,</p></blockquote><ul><li>집합 함수의 결과로는 NULL이 반환된다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="k">MIN</span><span class="p">(</span><span class="n">dept_no</span><span class="p">),</span> <span class="k">MAX</span><span class="p">(</span><span class="n">dept_no</span><span class="p">)</span>
<span class="k">FROM</span> <span class="n">dept_emp</span> <span class="k">WHERE</span> <span class="n">dept_no</span><span class="o">=</span><span class="s1">''</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td> <td> <td> <td> <td> <td> <td>No matching min/max row</table></div><h3 id="no-matching-row-in-const-table-51-버전부터">No matching row in const table (5.1 버전부터)</h3><blockquote><p>조인에 사용된 테이블에서 const 방식으로 접근할 때, 일치하는 레코드가 없는 경우이다.</p></blockquote><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">dept_emp</span> <span class="n">de</span><span class="p">,</span>
<span class="p">(</span><span class="k">SELECT</span> <span class="n">emp_no</span> <span class="k">FROM</span> <span class="n">employees</span> <span class="k">WHERE</span> <span class="n">emp_no</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">tb1</span>
<span class="k">WHERE</span> <span class="n">tb1</span><span class="p">.</span><span class="n">emp_no</span><span class="o">=</span><span class="n">de</span><span class="p">.</span><span class="n">emp_no</span> <span class="k">AND</span> <span class="n">de</span><span class="p">.</span><span class="n">dept_no</span><span class="o">=</span><span class="s1">'d005'</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>PRIMARY<td> <td> <td> <td> <td> <td> <td>Impossible WHERE noticed<br />after reading const tables<tr><td>2<td>DERIVED<td> <td> <td> <td> <td> <td> <td>no matching row in const table</table></div><h3 id="unique-row-not-found-51-버전부터">Unique row not found (5.1 버전부터)</h3><blockquote><p>두 개의 테이블이 각각 유니크(프라이머리 키 포함) 컬럼으로 아우터 조인을 수행하는 쿼리에서, 아우터 테이블에 일치하는 레코드가 존재하지 않는 경우이다.</p></blockquote><ul><li>t2 테이블에 프라이머리 키인 fdpk의 값이 1인 레코드만 있다고 가정해보자.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="n">t1</span><span class="p">.</span><span class="n">fdpk</span>
<span class="k">FROM</span> <span class="n">tb_test1</span> <span class="n">t1</span>
  <span class="k">LEFT</span> <span class="k">JOIN</span> <span class="n">tb_test2</span> <span class="n">t2</span> <span class="k">ON</span> <span class="n">t2</span><span class="p">.</span><span class="n">fdpk</span><span class="o">=</span><span class="n">t1</span><span class="p">.</span><span class="n">fdpk</span>
<span class="k">WHERE</span> <span class="n">t1</span><span class="p">.</span><span class="n">fdpk</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>t1<td>const<td>PRIMARY<td>4<td>const<td>1<td>Using index<tr><td>2<td>SIMPLE<td>t2<td>const<td>PRIMARY<td>4<td>const<td>0<td>unique row not found</table></div><p><br /></p><h2 id="2-쿼리의-실행-계획이-좋지-않은-경우">2. 쿼리의 실행 계획이 좋지 않은 경우</h2><blockquote><p>아래와 같은 코멘트가 표시된다면 쿼리를 더 최적화할 수 있는지 검토해보는 것이 좋다. 특히, ‘Using where’의 경우 대부분의 쿼리에서 표시되기 때문에 그냥 지나치기 쉬운데, 만약 실행 계획의 rows 컬럼 값이 실제 SELECT되는 레코드 건수보다 훨씬 더 높은 경우에는 둘의 차이를 줄이는 것이 중요하다.</p></blockquote><h3 id="range-checked-for-each-record-index-mapn">Range checked for each record (index map:N)</h3><blockquote><p>매 레코드마다 인덱스 레인지 스캔을 할지, 풀 테이블 스캔을 할지 결정한다.</p></blockquote><ul><li>아래 쿼리 처럼 조인 조건에 상수가 없고 둘 다 변수인 경우, e1 테이블의 레코드를 하나씩 읽을 때 마다 e1.emp_no 값이 계속 바뀌므로 쿼리의 비용 계산을 위한 기준값이 계속 변한다.<ul><li>따라서, 어떤 접근 방법으로 e2 테이블을 읽는 것이 좋을지 판단할 수 없는 것이다.</ul><li>‘(index map: 0x1)’은 사용할지 말지를 판단하는 후보 인덱스의 순번을 나타낸다.<ul><li>어떤 인덱스인지 확인하려면 16진수를 2진수로 바꿔야한다.<li>0x1은 이진수 1이기 때문에 이는 첫 번째 인덱스를 의미힌다.<li><code class="language-plaintext highlighter-rouge">SHOW CREATE TABLE employees</code> 명령어를 통해 인덱스 순서를 확인할 수 있다.</ul><li>type에 ‘ALL’로 표시되었지만 무조건 풀 테이블 스캔을 하는 것은 아니다.<ul><li>즉, ‘Range checked for each record’인 경우에는 후보 인덱스를 사용할지를 검토해서, 인덱스를 사용하지 않는 경우 ‘ALL’ 접근 방법을 사용한다.</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">employees</span> <span class="n">e1</span><span class="p">,</span> <span class="n">employees</span> <span class="n">e2</span>
<span class="k">WHERE</span> <span class="n">e2</span><span class="p">.</span><span class="n">emp_no</span> <span class="o">&gt;=</span> <span class="n">e1</span><span class="p">.</span><span class="n">emp_no</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>e1<td>ALL<td> <td>3<td> <td>300584<td>Using index<tr><td>2<td>SIMPLE<td>e2<td>ALL<td> <td>3<td> <td>300584<td>Range checked for<br />each record<br />(index map: 0x1)</table></div><h3 id="using-filesort">Using filesort</h3><blockquote><p><code class="language-plaintext highlighter-rouge">ORDER BY</code> 처리가 인덱스를 사용하지 못하는 경우이다.</p></blockquote><ul><li>조회된 레코드를 정렬하기 위해, 정렬용 메모리 버퍼(sort buffer)에 복사해서 퀵 소트 알고리즘을 수행한다.<li>이러한 경우는 많은 부하를 일으킬 수 있으므로, 쿼리를 튜닝하거나 인덱스를 생성하는 것이 좋다.</ul><h3 id="using-join-buffer-51-버전부터">Using join buffer (5.1 버전부터)</h3><blockquote><p>조인 버퍼가 사용되는 실행 계획이다. 조인 버퍼는 읽은 레코드를 임시로 보관해두는 메모리 공간이다.</p></blockquote><ul><li>실제로 조인에 필요한 인덱스는 조인에서 뒤에 읽는 테이블(드리븐 테이블)의 컬럼에만 필요하다.<ul><li>드리븐 테이블은 검색 위주로 사용되기 때문에, 인덱스가 없으면 성능에 미치는 영향이 매우 크다.<li>드리븐 테이블에 적절한 인덱스가 없다면, 드라이빙 테이블로부터 읽은 레코드의 건수만큼 매번 드리븐 테이블을 풀 테이블 스캔이나 인덱스 풀 스캔해야 할 것이다.<li>이러한 비효율성을 보완하기 위해, MySQL 서버는 드라이빙 테이블에서 읽은 레코드를 임시 공간에 보관해두고 필요할 때 재사용할 수 있게 해준다.<li><code class="language-plaintext highlighter-rouge">join_buffer_size</code> 시스템 설정 변수를 활용하여 버퍼 크기를 설정할 수 있다.</ul><li>옵티마이저는 조인되는 두 테이블에 있는 인덱스를 조사하고, 인덱스가 없는 테이블이 있으면 그 테이블을 먼저 읽어서 조인을 실행한다.<li>다음과 같은 카테시안 조인을 수행하는 쿼리는 항상 조인 버퍼를 사용한다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">dept_emp</span> <span class="n">de</span><span class="p">,</span> <span class="n">employees</span> <span class="n">e</span>
<span class="k">WHERE</span> <span class="n">de</span><span class="p">.</span><span class="n">from_date</span><span class="o">&gt;</span><span class="s1">'2005-01-01'</span> <span class="k">AND</span> <span class="n">e</span><span class="p">.</span><span class="n">emp_no</span><span class="o">&lt;</span><span class="mi">10904</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>de<td>range<td>ix_fromdate<td>3<td> <td>1<td>Using where<tr><td>2<td>SIMPLE<td>e<td>range<td>PRIMARY<td>4<td> <td>1520<td>Using where;<br />Using join buffer</table></div><h3 id="using-temporary">Using temporary</h3><blockquote><p>쿼리를 처리하기 위해 임시 테이블을 사용한 것이다.</p></blockquote><ul><li>MySQL은 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블을 사용한다.<ul><li>임시 테이블이 메모리에 생성됐는지, 디스크에 생성됐는지 여부는 실행 계획만으로는 판단할 수 없다.</ul><li>아래 쿼리는 <code class="language-plaintext highlighter-rouge">GROUP BY</code> 컬럼과 <code class="language-plaintext highlighter-rouge">ORDER BY</code> 컬럼이 다르기 때문에 임시 테이블이 필요한 작업이다.</ul><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>employees<td>ALL<td> <td> <td> <td>300584<td>Using temporary;<br />Using filesort</table></div><ul><li>Extra 컬럼에 ‘Using temporary’가 표시되지는 않지만, 내부적으로 임시 테이블을 사용할 때도 많다.<ul><li><code class="language-plaintext highlighter-rouge">FROM</code> 절에 사용된 서브쿼리는 무조건 임시 테이블(파생 테이블)을 생성한다.<li><code class="language-plaintext highlighter-rouge">COUNT(DISTINCT col1)</code>을 포함하는 쿼리는 인덱스를 사용할 수 없는 경우 임시 테이블을 생성한다.<li><code class="language-plaintext highlighter-rouge">UNION</code>, <code class="language-plaintext highlighter-rouge">UNION ALL</code>이 사용된 쿼리도 임시 테이블을 사용하여 결과를 병합한다.<li>정렬에 버퍼가 사용되는 경우, 버퍼의 실체도 결국은 임시 테이블이다.</ul></ul><h3 id="using-where">Using where</h3><blockquote><p>MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우이다.</p></blockquote><ul><li>스토리지 엔진은 디스크나 메모리상에서 필요한 레코드를 읽거나 저장한다.<li>MySQL 엔진은 스토리지 엔진으로부터 받은 레코드를 가공 또는 연산한다.<li>작업 범위 제한 조건은 스토리지 엔진 레벨에서, 체크 조건은 MySQL 엔진 레벨에서 처리된다.<ul><li>아래 쿼리의 경우, 스토리지 엔진에서 100개의 레코드를 MySQL 엔진으로 넘겨준다.<li>MySQL 엔진은 체크 조건(<code class="language-plaintext highlighter-rouge">gender='F'</code>)을 통해 레코드를 필터링한다.<ul><li>‘Using where’는 필터링돼서 레코드를 버리는 처리를 의미한다.</ul></ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span>
<span class="k">WHERE</span> <span class="n">emp_no</span> <span class="k">BETWEEN</span> <span class="mi">10001</span> <span class="k">AND</span> <span class="mi">10100</span> <span class="k">AND</span> <span class="n">gender</span><span class="o">=</span><span class="s1">'F'</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>employees<td>range<td>PRIMARY<td>4<td>NULL<td>100<td>Using where</table></div><ul><li>‘Using where’가 성능상의 문제를 일으킬지 아닐지는 5.1 버전부터 추가된 ‘Filtered’ 컬럼을 통해 확인할 수 있다.</ul><p><br /></p><h2 id="3-쿼리의-실행-계획이-좋은-경우">3. 쿼리의 실행 계획이 좋은 경우</h2><h3 id="distinct">Distinct</h3><ul><li>아래 쿼리는 departments 테이블과 dept_emp 테이블에 모두 존재하는 dept_no만 유니크하게 가져오기 위한 쿼리이다.<li><code class="language-plaintext highlighter-rouge">DISTINCT</code>를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 필요한 것만 조인한다(필요한 레코드만 읽는다).</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="n">d</span><span class="p">.</span><span class="n">dept_no</span>
<span class="k">FROM</span> <span class="n">departments</span> <span class="n">d</span><span class="p">,</span> <span class="n">dept_emp</span> <span class="n">de</span> <span class="k">WHERE</span> <span class="n">de</span><span class="p">.</span><span class="n">dept_no</span><span class="o">=</span><span class="n">d</span><span class="p">.</span><span class="n">dept_no</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>d<td>index<td>ux_deptname<td>123<td>NULL<td>9<td>Using index;<br />Using temporary<tr><td>1<td>SIMPLE<td>de<td>ref<td>PRIMARY<td>12<td>d.dept_no<td>18603<td>Using index;<br />Distinct</table></div><h3 id="using-index커버링-인덱스">Using index(커버링 인덱스)</h3><blockquote><p>인덱스만 읽어서 쿼리를 모두 처리할 수 있는 경우이다.</p></blockquote><ul><li>인덱스를 이용해 처리하는 쿼리에서 가장 큰 부하를 차지하는 부분은 인덱스를 검색해 일치하는 레코드의 나머지 컬럼 값을 가져오기 위해 데이터 파일을 찾아서 가져오는 작업이다.<li>최악의 경우에는 인덱스를 통해 검색된 결과 레코드 한 건 한 건마다 디스크를 한 번씩 읽어야 할 수도 있다.<li>InnoDB의 모든 테이블은 클러스터링 인덱스로 구성돼 있다.<ul><li>즉, InnoDB 테이블의 모든 보조 인덱스는 데이터 레코드의 주소 값으로 프라이머리 키 값을 가진다.<li>이러한 특성 때문에 쿼리가 커버링 인덱스로 처리될 가능성이 상당히 높다.</ul><li>하지만 무조건 커버링 인덱스로 처리하려고 인덱스에 많은 컬럼을 추가하게 되면, 과도하게 인덱스의 컬럼이 많아져 메모리 낭비가 심해질 수 있다.<ul><li>또한, 레코드를 저장하거나 변경하는 작업이 매우 느려질 수 있다.</ul></ul><h3 id="using-index-for-group-by">Using index for group-by</h3><blockquote><p><code class="language-plaintext highlighter-rouge">GROUP BY</code> 처리가 인덱스를 이용하는 경우이다. 이러한 방법을 ‘루스 인덱스 스캔’이라고 한다.</p></blockquote><ul><li>루스 인덱스 스캔은 인덱스에서 필요한 부분만 읽는다.<ul><li>salaries 테이블의 인덱스는 emp_no, from_date로 구성되어 있다.<li>아래의 쿼리의 경우 emp_no 그룹별로 첫 번째 from_date 값(최솟값)과 마지막 from_date 값(최댓값)을 인덱스로부터 읽으면 된다.<li>따라서, ‘루스 인덱스 스캔’ 방식으로 처리할 수 있다.</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span>
<span class="k">SELECT</span> <span class="n">emp_no</span><span class="p">,</span> <span class="k">MIN</span><span class="p">(</span><span class="n">from_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">first_changed_date</span><span class="p">,</span> <span class="k">MAX</span><span class="p">(</span><span class="n">from_date</span><span class="p">)</span> <span class="k">AS</span> <span class="n">last_changed_date</span>
<span class="k">FROM</span> <span class="n">salaries</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">emp_no</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>salaries<td>range<td>PRIMARY<td>4<td> <td>711129<td>Using index for<br />group-by</table></div><h1 id="explain-extended">EXPLAIN EXTENDED</h1><hr /><blockquote><p>MySQL 5.1.12 미만의 버전에서는 MySQL 엔진에 의해 필터링 과정을 거치면서 얼마나 많은 레코드가 버려졌는지 알 수 없었다. 5.1.12 버전부터는 필터링이 얼마나 효율적으로 실행됐는지 알려주기 위해 ‘Filtered’ 컬럼이 추가되었다. 이를 확인하려면 <code class="language-plaintext highlighter-rouge">EXPLAIN EXTENDED</code> 명령어를 사용한다.</p></blockquote><ul><li>필터링된 레코드는 제외하고 최종적으로 레코드가 얼마나 남았는지 비율이 표시된다.<ul><li>즉, 전체 레코드 100건 중 20% (20건)만이 남았다는 의미다.</ul><li>이 값은 실제 값이 아닌 통계 정보로부터 예측된 값이다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">EXPLAIN</span> <span class="n">EXTENDED</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">employees</span>
<span class="k">WHERE</span> <span class="n">emp_no</span> <span class="k">BETWEEN</span> <span class="mi">10001</span> <span class="k">AND</span> <span class="mi">10100</span> <span class="k">AND</span> <span class="n">gender</span><span class="o">=</span><span class="s1">'F'</span><span class="p">;</span>
</pre></table></code></div></div><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>type<th>key<th>key_len<th>ref<th>rows<th>filtered<th>Extra<tbody><tr><td>1<td>SIMPLE<td>employees<td>range<td>PRIMARY<td>4<td>NULL<td>100<td>20<td>Using where</table></div><h1 id="explain-partitions">EXPLAIN PARTITIONS</h1><hr /><blockquote><p><code class="language-plaintext highlighter-rouge">EXPLAIN PARTITIONS</code> 명령을 통해 파티션 테이블의 실행 계획 정보를 좀 더 자세히 확인할 수 있다.</p></blockquote><ul><li>파티션이 여러 개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 ‘파티션 프루닝(Partition pruning)’이라고 한다.<li>이를 확인하기 위해 옵티마이저가 실제로 접근하는 파티션 테이블을 확인해 볼 수 있다.</ul><div class="table-wrapper"><table><thead><tr><th>id<th>select_type<th>table<th>partitions<th>type<th>key<th>key_len<th>ref<th>rows<th>Extra<tbody><tr><td>1<td>SIMPLE<td>tb_partition<td>p3<td>ALL<td> <td> <td> <td>2<td>Using where</table></div><h1 id="관련-글">관련 글</h1><hr /><ul><li><a href="https://zz9z9.github.io/posts/execution-plan-part1/">MySQL 실행 계획 (1)</a><li><a href="https://zz9z9.github.io/posts/execution-plan-part2/">MySQL 실행 계획 (2)</a></ul><h1 id="참고-자료">참고 자료</h1><hr /><ul><li>이성욱, 『개발자와 DBA를 위한 Real MySQL』, 위키북스(2012), 6장</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EC%A7%80%EC%8B%9D-%EB%8D%94%ED%95%98%EA%B8%B0/'>지식 더하기</a>, <a href='/categories/%EC%9D%B4%EB%A1%A0/'>이론</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/mysql/" class="post-tag no-text-decoration" >MySQL</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MySQL - MySQL 실행 계획 (3) - zz9z9&url=https://zz9z9.github.io/posts/execution-plan-part3/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MySQL - MySQL 실행 계획 (3) - zz9z9&u=https://zz9z9.github.io/posts/execution-plan-part3/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=MySQL - MySQL 실행 계획 (3) - zz9z9&url=https://zz9z9.github.io/posts/execution-plan-part3/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/daily-note-251016/">오늘 드는 생각 (251016, 은탄환)</a><li><a href="/posts/daily-note-251015/">오늘 드는 생각 (251015, 일과 공부)</a><li><a href="/posts/thinking-about-maintenance/">유지보수하기 어렵다 ?</a><li><a href="/posts/mysql-nested-loop-join/">MySQL - Nested-Loop Join 알아보기</a><li><a href="/posts/mysql-hash-join/">MySQL - Hash Join 알아보기</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/web/">WEB</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/http/">HTTP</a> <a class="post-tag" href="/tags/spring-batch/">Spring Batch</a> <a class="post-tag" href="/tags/oop/">OOP</a> <a class="post-tag" href="/tags/mybatis/">MyBatis</a> <a class="post-tag" href="/tags/os/">OS</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/mysql-nested-loop-join/"><div class="card-body"> <span class="timeago small" > Oct 1 <i class="unloaded">2025-10-01T21:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL - Nested-Loop Join 알아보기</h3><div class="text-muted small"><p> Nested-Loop Join Algorithm MySQL은 테이블 간 조인을 수행할 때, 중첩 루프 조인(Nested-Loop Join, NLJ) 알고리즘(및 그 변형)을 사용한다. MySQL 8.0.18부터는 Hash Join도 지원 NLJ : 바깥(outer) 테이블에서 한 행씩 가져와 안쪽(inne...</p></div></div></a></div><div class="card"> <a href="/posts/transaction-and-isolation-level/"><div class="card-body"> <span class="timeago small" > Aug 24, 2021 <i class="unloaded">2021-08-24T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL - 트랜잭션과 격리 수준</h3><div class="text-muted small"><p> 트랜잭션과 ACID 트랜잭션이란 ? 데이터베이스 상태를 변경시키는 일련의 연산들을 논리적으로 묶을 수 있는 하나의 작업 단위 ex) 주문 - 결제 - 결제 승인 - 주문 접수 트랜잭션에는 중요한 두 가지 목적이 있다. ...</p></div></div></a></div><div class="card"> <a href="/posts/data-modeling/"><div class="card-body"> <span class="timeago small" > Aug 25, 2021 <i class="unloaded">2021-08-25T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MySQL - 데이터 모델링</h3><div class="text-muted small"><p> 들어가기 전 애플리케이션을 설계할 때 ‘DB 테이블은 어떻게 구성해야하지?’ 에 대한 막막함이 있다면 데이터 모델링이 문제 해결의 출발점이라고 생각한다. 공부를 하기에 앞서 나의 언어로 정리해본다면 내가 생각하기에 모델링이라는 것은 먼저 문자 그대로 ‘모델화’ 시킨다는 것인데, 모델이란 ‘어떤 대상을 필요한 특징만 추려서 나타낸 것’ 이라는 생...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/execution-plan-part2/" class="btn btn-outline-primary" prompt="Older"><p>MySQL - MySQL 실행 계획 (2)</p></a> <a href="/posts/number-baseball-part1/" class="btn btn-outline-primary" prompt="Newer"><p>숫자 야구 게임 구현하기 (1)</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">Lee JaeYoon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/mysql/">MySQL</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/web/">WEB</a> <a class="post-tag" href="/tags/infra/">Infra</a> <a class="post-tag" href="/tags/http/">HTTP</a> <a class="post-tag" href="/tags/spring-batch/">Spring Batch</a> <a class="post-tag" href="/tags/oop/">OOP</a> <a class="post-tag" href="/tags/mybatis/">MyBatis</a> <a class="post-tag" href="/tags/os/">OS</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://zz9z9.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
