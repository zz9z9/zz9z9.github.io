<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://zz9z9.github.io/</id><title>zz9z9</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2026-02-10T23:25:48+09:00</updated> <author> <name>Lee JaeYoon</name> <uri>https://zz9z9.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://zz9z9.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://zz9z9.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2026 Lee JaeYoon </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>JPA / MyBatis 혼용시 주의사항 (in 배치 애플리케이션)</title><link href="https://zz9z9.github.io/posts/cautions-when-jpa-mybatis-together/" rel="alternate" type="text/html" title="JPA / MyBatis 혼용시 주의사항 (in 배치 애플리케이션)" /><published>2026-02-10T22:00:00+09:00</published> <updated>2026-02-10T22:00:00+09:00</updated> <id>https://zz9z9.github.io/posts/cautions-when-jpa-mybatis-together/</id> <content src="https://zz9z9.github.io/posts/cautions-when-jpa-mybatis-together/" /> <author> <name>Lee JaeYoon</name> </author> <category term="JPA" /> <summary> JPA와 MyBatis는 서로의 존재를 모른다. MyBatis는 JDBC를 직접 사용하므로 JPA 영속성 컨텍스트를 우회하여 DB를 변경하고, JPA는 이를 감지할 수 없다. 결과적으로 JPA 1차 캐시에는 변경 전 데이터(stale data)가 남게 되어 데이터 불일치가 발생한다. 문제 상황 예시 1. 같은 엔티티를 JPA로 읽고 MyBatis로 UPDATE @Bean public Step problematicStep() { return stepBuilder("step") .&amp;lt;BatchTarget, BatchTarget&amp;gt;chunk(100, transactionManager) .reader(jpaReader()) // ... </summary> </entry> <entry><title>이슈 - JpaItemWriter로 엔티티 저장시, ChunkSize만큼 SELECT 쿼리 발생하는 상황</title><link href="https://zz9z9.github.io/posts/how-jpa-item-writer-merge-works/" rel="alternate" type="text/html" title="이슈 - JpaItemWriter로 엔티티 저장시, ChunkSize만큼 SELECT 쿼리 발생하는 상황" /><published>2026-01-29T23:00:00+09:00</published> <updated>2026-01-29T23:00:00+09:00</updated> <id>https://zz9z9.github.io/posts/how-jpa-item-writer-merge-works/</id> <content src="https://zz9z9.github.io/posts/how-jpa-item-writer-merge-works/" /> <author> <name>Lee JaeYoon</name> </author> <category term="JPA" /> <summary> 상황 배치 애플리케이션에서 A 테이블에서 조회 -&amp;gt; 가공 -&amp;gt; B 테이블에 저장 흐름으로 동작하는 청크 기반의 Job이 있음 B 테이블에 저장시 JpaItemWriter 사용 B 테이블에 저장하는 엔티티의 PK는 A 테이블의 PK와 동일. 즉, A 테이블에서 조회한 엔티티의 PK가 사용됨 (Assigned ID + @Version 없음) 저장시 ChunkSize 만큼의 SELECT 쿼리가 발생함 원인 파악 결론 JpaItemWriter는 엔티티 저장시 기본적으로 EntityManager의 merge()를 호출 (usePersist가 true인 경우는 persist() 호출) merge()는 엔티티가 영속성 컨텍스트에 없고, DB 존재 여부를 판단할 수 없는... </summary> </entry> <entry><title>JPA/Hibernate ID 생성 전략</title><link href="https://zz9z9.github.io/posts/jpa-id-generation-strategy/" rel="alternate" type="text/html" title="JPA/Hibernate ID 생성 전략" /><published>2026-01-29T23:00:00+09:00</published> <updated>2026-02-05T23:57:55+09:00</updated> <id>https://zz9z9.github.io/posts/jpa-id-generation-strategy/</id> <content src="https://zz9z9.github.io/posts/jpa-id-generation-strategy/" /> <author> <name>Lee JaeYoon</name> </author> <category term="JPA" /> <summary> @GeneratedValue 기본 키(primary key) 값의 생성 전략을 지정하는 데 사용 즉, 데이터베이스에 새 레코드를 삽입할 때 기본 키 값을 자동으로 생성하는 방법을 지정 @GeneratedValue는 @Id와 함께 엔티티 또는 매핑된 슈퍼클래스의 기본 키 속성이나 필드에 적용할 수 있다. @GeneratedValue는 단순 기본 키(단일 컬럼으로 구성된 PK)에 대해서만 지원된다. 파생 기본 키(@MapsId로 다른 엔티티로부터 파생된 PK)에 대한 @GeneratedValue 사용은 지원되지 않는다. 생성 전략 전략 설명 AUTO JPA ... </summary> </entry> <entry><title>젠킨스 Pipeline 알아보기</title><link href="https://zz9z9.github.io/posts/jenkins-pipeline/" rel="alternate" type="text/html" title="젠킨스 Pipeline 알아보기" /><published>2026-01-26T22:25:00+09:00</published> <updated>2026-01-26T22:25:00+09:00</updated> <id>https://zz9z9.github.io/posts/jenkins-pipeline/</id> <content src="https://zz9z9.github.io/posts/jenkins-pipeline/" /> <author> <name>Lee JaeYoon</name> </author> <category term="지식 더하기" /> <category term="이론" /> <summary> Jenkins Pipeline CD(Continuous Delivery) 파이프라인을 코드로 정의하는 Jenkins 플러그인 모음 핵심 개념 Pipeline └── Stage └── Step 개념 설명 예시 Pipeline 전체 빌드 프로세스 정의 pipeline { } Node 파이프라인을 실행하는 머신 node { } (Scripted) Stage 논리적 작업 단위 “Build”, “Test”, “Deploy” Step 실제 수행... </summary> </entry> <entry><title>EntityManager와 영속성 컨텍스트</title><link href="https://zz9z9.github.io/posts/jpa-entity-manager-persistence-context/" rel="alternate" type="text/html" title="EntityManager와 영속성 컨텍스트" /><published>2026-01-25T23:00:00+09:00</published> <updated>2026-02-05T23:57:55+09:00</updated> <id>https://zz9z9.github.io/posts/jpa-entity-manager-persistence-context/</id> <content src="https://zz9z9.github.io/posts/jpa-entity-manager-persistence-context/" /> <author> <name>Lee JaeYoon</name> </author> <category term="JPA" /> <summary> Architecture Hibernate는 ORM 솔루션으로서 Java 애플리케이션의 데이터 접근 계층과 관계형 데이터베이스 사이에 위치 Java 애플리케이션은 Hibernate API를 사용하여 도메인 데이터를 로드, 저장, 쿼리한다. Data Access Layer (데이터 접근 계층) ↓ ┌─────────────────────────────────┐ │ Java Persistence │ Hibernate │ │ API │ Native API│ ├─────────────────────────────────┤ │ Hibernate │ ├───... </summary> </entry> </feed>
