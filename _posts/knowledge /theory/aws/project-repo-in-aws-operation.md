
## 멀티모듈 vs 프로젝트 분리
---
- Docker + GitHub Actions + ECS 같은 클라우드·컨테이너 기반 환경에서는 멀티모듈 사용이 확실히 줄어든다.

### 왜 기존 환경에서는 멀티모듈을 많이 썼을까?
- 기존(Jenkins + JAR 직접 배포) 환경에서 멀티모듈을 많이 쓴 이유는:
  - 공통 모듈(core)을 여러 서비스(api/admin/batch)가 공유해야 했고
  - **하나의 프로젝트 안에 있는게 빌드/버전 관리/배포가 쉽기 때문**

- 즉, 아래와 같은 구조로 전체를 한 번에 빌드 → 각각 JAR 만들어 배포하는 패턴.

```
parent
├─ core
├─ api
├─ admin
├─ batch
```

### Docker 기반에서는 왜 멀티모듈을 덜 쓸까?
- Docker + ECS 같은 환경에서는 서비스가 각각 독립적인 컨테이너가 됨.
- 즉, “서비스 = 컨테이너 = 하나의 독립된 배포 단위”
- 예를 들어:
  - API → 하나의 컨테이너
  - ADMIN → 하나의 컨테이너
  - BATCH → 하나의 컨테이너
- 각각 별도로 빌드/배포/롤백된다.
- 이러면 멀티모듈 내부에서 한 번에 빌드할 필요가 줄어듦 ??
- 왜냐면 멀티모듈의 장점(한 번에 전체 빌드 & 패키징)이 컨테이너 환경에서는 오히려 단점이 되기 때문. ??

### Docker 환경에서 멀티모듈이 줄어드는 실질적인 이유
- 서비스가 각각 독립 빌드 → 멀티모듈이 발목 잡음
  - ECS는 “하나의 서비스 = 하나의 이미지” 개념
  - 멀티모듈이면 모든 모듈을 매번 함께 빌드해야 함
  - 이건 Docker 이미지 빌드 속도를 크게 느리게 함

- core 모듈 같은 공통 라이브러리는 Nexus/ECR에서 버전으로 관리하는게 일반적
  - 컨테이너 시대에는 공유 기능은 보통:
    - 독립 repo로 운영됨
    - Maven Central 또는 사내 Nexus/ECR로 배포됨
    - 서비스는 그걸 dependency로 받음
  - 즉 멀티모듈 유지할 이유가 많이 사라짐.

- 빌드 캐시 효율성이 떨어짐
  - Docker 빌드는 레이어 캐시가 핵심인데 멀티모듈이면:
    - 소스 전체가 변경되었는지 판단하기 어렵고
    - Docker 캐시가 계속 깨짐
  -  매우 비효율적

- 반면 서비스별 repo로 분리하면:
  - 변경된 서비스만 Docker build
  - Build 속도 빠름
  - ECS 배포도 더 가벼움

### 그렇다면 멀티모듈은 아예 안 쓰는 걸까?
> 여전히 사용되는 경우가 있음:

**1. 단일 프로젝트 모노리식 구조**
- 예: 하나의 API 서버 + 내부 기능이 여러 모듈로 나뉨

```
my-app
├─ core
├─ domain
├─ infrastructure
└─ api
```

- 최종적으로 JAR 1개 생성 + Docker 이미지 1개 만들면 OK
- 이런 구조는 “아키텍처를 정리하는 용도”로 멀티모듈 사용

**2. 같이 버전 관리하는 라이브러리 묶음**
- 예: 회사 내부 SDK, 인증 라이브러리 등
  - 이런 건 멀티모듈을 유지해도 됨
  - 출시는 Nexus나 internal registry로 진행

### 실제 AWS ECS 운영 환경에서는 어떤 방식이 표준일까?

- 이전 방식(모놀리식 멀티모듈)

```
parent
├─ core
├─ api
├─ admin
├─ batch
```

- 추천 방식(컨테이너 시대)

```
core-lib       (공통 라이브러리 repo)
api-service    (독립 repo → 독립 Docker image)
admin-service  (독립 repo → 독립 Docker image)
batch-service  (독립 repo → 독립 Docker image)
```

이게 배포/스케일링/롤백에서 훨씬 유리함.




## Claude 의견

ECS + ECR + Docker 환경에서 멀티모듈 vs 단일모듈 선택은 팀 상황에 따라 달라지는데, 각각의 장단점을 정리해볼게.

### 멀티모듈 구조 (하나의 프로젝트)
- 장점:
  - 코드 공유가 쉬움 - core 모듈의 공통 코드를 즉시 참조 가능. 버전 관리 불필요
  - 리팩토링이 편함 - 한 번의 PR로 여러 모듈 동시 수정 가능
  - 일관성 유지 - 의존성 버전, 코딩 스타일, 설정이 자연스럽게 통일됨
  - 초기 구축 빠름 - 레포지토리 하나만 관리하면 됨

- 단점:
  - 빌드 시간 - 전체 프로젝트를 빌드해야 해서 느릴 수 있음 (Gradle 빌드 캐시로 완화 가능)
  - 배포 복잡도 - Dockerfile 여러 개 또는 multi-stage build 필요. 어떤 모듈이 변경됐는지 감지 필요
  - 권한 관리 어려움 - admin 팀만 admin에 접근하도록 제한하기 어려움
  - 독립성 부족 - 한 모듈의 이슈가 전체 빌드/배포를 막을 수 있음

### 단일모듈 여러 프로젝트 (각각의 프로젝트)
- 장점:
  - 독립적 배포 - 각 서비스를 완전히 독립적으로 배포 가능
  - 빌드 속도 - 변경된 프로젝트만 빌드
  - 명확한 경계 - 팀별 소유권, 권한 관리가 명확함
  - 기술 스택 자유도 - 필요시 각 프로젝트가 다른 버전/라이브러리 사용 가능

- 단점:
  - 코드 중복 위험 - core를 라이브러리로 분리해야 하는데, 귀찮아서 중복 코드 발생 가능
  - 버전 관리 복잡 - core 라이브러리 버전 업데이트 시 각 프로젝트 동기화 필요
  - 크로스 모듈 변경 어려움 - core + api 동시 수정 시 2개 PR, 버전 배포, 업데이트 과정 필요
  - 관리 포인트 증가 - CI/CD 파이프라인, 레포지토리 관리가 배로 늘어남

### 실무 추천
- 멀티모듈을 추천하는 경우:
  - 팀이 작거나 중간 규모 (10명 이하)
  - 서비스들이 강하게 결합되어 있고 함께 변경되는 경우가 많음
  - 빠른 개발 속도가 중요
  - core 로직이 자주 변경됨

- 단일모듈을 추천하는 경우:
  - 팀이 크고 명확하게 분리됨 (admin팀, api팀 등)
  - 서비스들이 독립적으로 운영되고 배포 주기가 다름
  - 마이크로서비스 아키텍처를 지향
  - core가 안정적이고 거의 변경되지 않음

- Docker/ECS 관점에서 멀티모듈이라도 ECS 배포는 문제없음:
  - dockerfile# 각 모듈별 Dockerfile

FROM gradle:jdk17 AS builder
COPY . .
RUN gradle :admin:bootJar

FROM openjdk:17-slim
COPY --from=builder /app/admin/build/libs/*.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]

- ECR도 각 모듈별로 이미지 분리 가능:

my-repo/admin:latest
my-repo/api:latest
my-repo/batch:latest

내 생각: 처음 시작한다면 멀티모듈로 가고, 팀이 커지거나 독립성이 필요해지면 그때 분리하는게 현실적이야. 처음부터 분리하면 초기 오버헤드가 크고, 실제로 독립성이 필요한지 검증도 안됐을 수 있거든.

## GPT 의견
---
- ECS/Fargate + ECR 기반의 컨테이너 배포라면, 단일 레포지토리 멀티모듈 보다는 _단일 모듈의 여러 독립 레포지토리(서비스 단위 프로젝트)_가 더 적합합니다.

- 다만, 공통 코드(도메인, 유틸, AOP, 공통 Exception Handling 등)의 강한 재사용성과 일관된 버전 관리를 원한다면 멀티모듈도 나쁘지 않습니다.

- AWS ECS 환경은 배포 단위가 컨테이너이기 때문에 모듈 의존성을 강하게 가지는 멀티모듈 구조가 생각보다 큰 이점이 없고, CI/CD·롤백·독립 배포·스케일링에서는 오히려 독립 프로젝트가 유리합니다.

### 멀티모듈 하나의 프로젝트
> admin, api, batch, core가 하나의 Gradle / Maven 프로젝트 안에 존재하는 구조

**장점**
- 공통 코드 재사용 간편:
  - core 모듈로 domain, util, common exception, validation 등을 공유.
  - 버전 관리가 쉬움(모든 모듈이 같은 dependency 버전 사용).

- 개발 환경이 단일 IDE 프로젝트로 통합:
  - 개발자가 더 보기 쉽고 구조가 명확함.
  - refactoring 시 전체 영향도 파악이 쉬움.

- 코드 리뷰나 규칙 통일성이 높음:
  - 전체 서비스가 하나의 코드베이스에서 관리됨.

**단점**
- 배포 단위가 함께 엮임:
  - admin 수정했는데 api도 이미지 다시 빌드해야 하는 경우 발생
  - 실제로는 모듈별 Dockerfile 빌드가 가능하지만, build 환경이 거대해지고 CI/CD가 비효율적
- 모듈 간 build 캐시가 공유되며 불필요한 빌드 증가

- 서비스 독립 배포가 어려움:
  - API만 롤백하려 해도 전체 버전이 묶여버림
  - ECS task definition 버전도 강제로 맞춰야 하는 등 관리 복잡

- 장애 전파 위험:
  - 하나의 코드를 잘못 수정하면 나머지 모듈 컴파일/빌드까지 깨질 수 있음

- 스케일링 단위가 서비스별이 아님:
  - 결국 container는 모듈별로 나누지만 codebase는 하나라 운영 상 애매한 포지션이 됨 ??

### 단일 모듈 여러 프로젝트(서비스별 독립 레포지토리)
> admin, api, batch, core를 아예 다른 프로젝트로 관리

**장점**
- 컨테이너 단위로 완전한 독립 배포:
  - admin → 작업 끝나면 admin만 이미지 빌드 후 ECS 업데이트
  - api/batch에 영향 없음
  - 롤백/카나리 배포도 개별 서비스만 적용 가능

- ECS의 스케일링 모델과 잘 맞음:
  - API는 Fargate AutoScaling
  - batch는 온디맨드 실행
  - admin은 저부하로 최소값 유지
  - 서비스별 독립된 확장성을 유지할 수 있음

- CI 파이프라인이 훨씬 단순:
  - 각 Repo에서 테스트→Docker build→ECR push→ECS deploy만 수행
  - 빌드 시간이 짧아지고 Github Actions 비용도 절약됨

- 장애 전파 줄어듦:
  - 특정 서비스 repo 빌드 오류가 전체를 막지 않음

**단점**
- 공통 코드의 버전 관리가 번거롭다:
  - core 모듈처럼 공유할 내용은
    - private Maven repo(ECR Public Gallery, GitHub Packages, CodeArtifact 등)
      또는
    -  git submodule
  - 등 별도 관리 필요.

- 전체 아키텍처를 한눈에 보기 어려움:
  - 개발자가 여러 repo를 이동하며 봐야 함.

- 공통 policy, 공통 dependency 버전 관리가 통일되기 어렵다
  - API는 spring boot 3.4, admin은 3.2 이런 식으로 버전이 엇갈릴 가능성

### GPT 의견 정리

**서비스 기능 단위로 완전 분리되는 경우 → 독립 프로젝트가 최적**
- 예: admin UI, API 서버, 배치 서버, 데이터 프로세싱 등
- 각각 스케일링, 배포, 장애 영향도가 다르기 때문에 AWS 컨테이너 생태계에서는 레포지토리도 서비스 단위로 분리하는 것이 가장 맞습니다.

**공통 코드가 많아서 재사용성이 중요 → 멀티모듈 선택 가능**
- 특히 다음 조건에 해당하면 멀티모듈이 더 적합해질 수 있음:
  - admin, api, batch가 하나의 도메인을 매우 강하게 공유
  - 공통 로직이 매우 크고 빈번하게 변경됨
  - 모든 서비스가 항상 같은 버전의 core 기능을 사용해야 함
- 이 경우 독립 프로젝트로 나누면 오히려 버전 충돌, 배포 순서 문제 등이 복잡해짐.

## 내 생각
---

### 멀티모듈 + 단일 repo
**장점**
- 공통 코드 관리하기 좋다:
  - 예를 들어, core 모듈의 어떤 코드를 어디서 사용하는지 한눈에 파악하기 좋음.
    - 공통으로 사용하는 로직이 많으면, 멀티모듈이 좋을듯 (ex : a 데이터 어디서 변경되는거지 ? -> 특정 엔티티의 a 값 변경되는 부분 한 눈에 파악 가능)
    - 유틸성이 아닌 이런식으로 실제 데이터 DML 처리하는 로직을 공통으로 사용해야할 일이 많으면, 멀티모듈이 좋을듯
  - 같은 맥락으로, 더이상 사용되지 않는 코드도 제거하기가 편함 (여러 플젝에서 사용하면, 어디서 사용하는지 일일이 체크하기 어려울듯)

- 정산은 데이터 가져와서, 가공하고, 어드민에서 보여주는 흐름이 강한 것 같음
- 이런 흐름을 수월하게 파악하려면 하나의 repo에서 코드 보는게 좋지 않을까 ?

- 멀티모듈 -> 필요할때, 단일 repo로 분리하는건 크게 안어렵지 않을까 ?

### 단일모듈 + 여러 repo


## QQQ
---

API → 하나의 컨테이너
ADMIN → 하나의 컨테이너
BATCH → 하나의 컨테이너
- API → 하나의 컨테이너, ADMIN → 하나의 컨테이너
=> 각각 별도로 빌드/배포/롤백된다 ??
=> 멀티모듈인 경우에도 서비스별 jar로 되니까, 각각 되는거아닌가 ?? 다만, 버전은 같이 올라가긴 하겠지만

- 빌드 시간이 짧아지고 **Github Actions 비용**도 절약됨 ?

- 컨테이너 시대에는 공유 기능은 보통 독립 repo로 운영됨 ?? 같은 프로젝트 내에서 하는거보다 이점 ?

- 하나의 프로젝트 안에 있는게 빌드/버전 관리/배포가 쉽기 때문 ??

- 왜냐면 멀티모듈의 장점(한 번에 전체 빌드 & 패키징)이 컨테이너 환경에서는 오히려 단점이 되기 때문. ??

- Docker 빌드는 레이어 캐시가 핵심인데 멀티모듈이면:
  - 소스 전체가 변경되었는지 판단하기 어렵고
  - Docker 캐시가 계속 깨짐 ??


- ECS의 스케일링 모델과 잘 맞음:
  - API는 Fargate AutoScaling
  - batch는 온디맨드 실행
  - admin은 저부하로 최소값 유지
  - 서비스별 독립된 확장성을 유지할 수 있음
    => 이거는 멀티모듈일 때도 가능한거 아닌가 ? 각각의 컨테이너로 동작하니까


## QnA 1. 멀티모듈 전체 빌드 ?

> 근데 멀티모듈 구조의 단점 중 하나라고 얘기한, "빌드 시간 - 전체 프로젝트를 빌드해야 해서 느릴 수 있음" => 이 부분이 잘 이해가 안되는데, 멀티모듈 구조더라도 실제 빌드때는 clean install -p ${phase} -Dmaven.test.skip -pl admin -am -s ./settings.xml 이런식으로 필요한 모듈만 빌드하는데, 전체를 빌드한다는게 어떤 의미야 ?

- 말씀한 것처럼 멀티모듈이라도 -pl 옵션으로 특정 모듈만 빌드할 수 있고, 실제 CI에서도 많이 쓰는 방식입니다.
- 그런데도 멀티모듈을 “전체 빌드를 한다”고 표현하는 이유는 물리적으로 **모든 모듈이 하나의 빌드 그래프(Dependency Graph) 안에 묶여 있기 때문**입니다.
- 즉, “전체 코드베이스에 대한 빌드 의존성이 존재한다”는 의미이지, CI가 항상 모든 모듈을 무조건 빌드한다는 뜻은 아닙니다.
- **“전체를 빌드한다”의 의미 = “전체 프로젝트가 하나의 빌드 단위(build graph)에 묶여 있다”
  입니다.**

**빌드 그래프(Dependency Graph) ?**
- Gradle도 멀티모듈(project) 구조에서는 전체 프로젝트의 빌드 그래프를 구성해야 하고, 특정 모듈만 빌드하더라도 전체 그래프 분석이 선행된다.
- 즉, Maven과 같은 문제가 똑같이 존재하고, 심지어 Gradle은 더 복잡한 그래프를 가지므로 영향 범위가 더 커질 수 있습니다.

- Gradle 실행 시:
  - settings.gradle 읽음
  - 모든 프로젝트(parent + subproject)의
    - build.gradle(.kts)
    - dependencies
    - plugins
  - 을 분석해서 전체 프로젝트의 Task Graph를 생성
- 즉, `:admin:build`만 실행해도, Gradle은 **“root + 모든 모듈”의 설정과 종속성을 한번은 로드함.**
- 이것이 바로 “전체 빌드 그래프가 만들어진다”는 의미.

- Gradle은 다음 과정을 거칩니다:
  - 1. Configuration Phase
    - build.gradle과 모든 서브 모듈의 설정을 분석
    - 모든 task를 정의
    - 전체 dependency graph 생성

  - 2. Execution Phase
    - 사용자가 실행한 task만 실행
    - 즉, Maven은 goal 중심(build lifecycle), Gradle은 task 중심(task dependency graph)

- 그래서 Gradle에서는 graph 구성 비용이 더 크다는 말이 나옵니다.
- 따라서, `./gradlew :admin:build` 할 때, 즉, “admin만 빌드해!” 라고 해도:
  -  Gradle은 전체 프로젝트를 로드(Configuration)
  -  admin에 필요한 종속 모듈(core 등)을 찾아서 빌드(Task Execution)
  -  나머지 모듈(task)은 실행하지 않음
- 그래서 전체 소스 체크아웃 + 전체 그래프 로딩 비용은 그대로 발생합니다.
- 이 점 때문에 멀티모듈이 커지면 Gradle도 빌드 시간이 늦어지는 원인이 됩니다.

**멀티모듈에서 -pl admin만 빌드하더라도 생기는 일**
> admin이 core를 참조한다고 가정.

root
├── core
├── api
├── admin
└── batch

- **root pom 전체를 한번은 읽는다**
- maven은 최상위 pom.xml을 로드 → 모듈 graph 구성 → 필요한 모듈만 빌드 순서라서 단일 프로젝트보다 초기화 작업이 무겁습니다.
- 단일 프로젝트(독립 repo)라면 root-level 빌드 그래프가 훨씬 작습니다.

**멀티모듈에서는 변경 영향으로 인해 빌드 범위가 넓어진다**
- 예를 들어 core 모듈을 조금만 수정해도: core 수정 → admin이 core를 사용 → admin도 전체 재빌드
- 즉, core 수정했는데 admin / api / batch 중 어느 것이 영향받을지 빌드 도구가 의존성을 따라가서 판단해야 함.

- 단일 서비스 repo였다면:
  - core는 따로 버전이 관리되고 각 서비스는 core X.Y 버전을 가져다 쓰므로
  - core를 수정해도 admin이 자동으로 rebuild될 필요가 없음 (= core 새 버전 배포할 때만 변경)

**멀티모듈은 빌드 캐시가 깨지기 쉽다**
- 예: root pom 수정 (dependency 버전 하나 올림)

→ 모듈 전체의 effective pom이 변경됨
→ Maven local repository, incremental build 캐시가 대부분 invalidation
→ 결국 전체 모듈이 recompile or repackage되는 경우가 늘어남

- 독립 프로젝트라면:
  - admin의 pom만 영향 있음
  - api/batch는 변경 없음 → 캐시 유지
  - 영향 범위가 서비스 단위로 분리됨
  - 즉 캐시 효율성이 현저히 다름.

**변경 영향도**
- core에 아주 작은 수정(주석 수정, 클래스 하나 수정)이 발생함.
- admin 자체 코드가 변경되지 않았더라도 dependency된 core가 변경되었기 때문에 admin도 재빌드가 필요함
- **즉, 코드 변경이 직접적이지 않아도 dependency 변경이므로 빌드 영향이 있음**
- 왜 admin이 재빌드(리패키징)되는가?
  - admin은 core의 class 파일을 직접 참조함.
  - core 컴파일 결과(output)이 달라지면 admin은 새 결과물을 이용하여 다시 컴파일/테스트/패키징해야 함.
  - 멀티모듈은 “동일 프로젝트”로 취급:
    - Gradle/Maven에서는 core와 admin이 한 프로젝트
    - core 변경은 프로젝트 변경
    - graph에서 dependent 모듈의 빌드 task도 영향을 받음

### QnA 1 내 생각
- 빌드 그래프가 커져서 단일 repo로 관리할때보다, 빌드 비용이 크다는건 어느정도 이해가 되는데, 그럼 그 정도의 비용이 실제 서비스 운영에 미치는 영향이 어느정도인거지 ?
- 사실 정산 서비스 성격상, 빌드 속도가 좀 더 걸린다고해서 크게 손해를 보거나 하는 부분은 없을 것 같은데

## QnA 2. 모듈간 장애 격리가 안된다 ?

> 멀티모듈의 단점 중 하나인, 독립성 부족 - 한 모듈의 이슈가 전체 빌드/배포를 막을 수 있음 ??
> 이건 무슨 의미야 ?? api -> admin에 영향을 끼치는 일은 없을 것 같은데, 공통으로 포함하는 core가 -> api, admin에 영향을 끼칠 수 있다는거야 ?? 예시좀

- admin과 api가 서로 직접 의존하지 않아도 둘 다 root 빌드의 일부이기 때문에 한쪽의 문제로 전체 CI/CD가 stop될 수 있음
- 특히 공통(core) 모듈이 문제가 되면 admin / api / batch 전부 빌드가 깨짐.

**예시 : core가 컴파일 오류를 일으킨 경우**
- core 프로젝트에서 실수로 문법 오류가 들어갔음.

```
core/
  User.java  ← 컴파일 에러 발생
```

- 멀티모듈 CI : `./gradlew clean build`
- 결과
  - core 컴파일 에러 → 전체 빌드 실패 → admin / api / batch 도 배포 불가
  - 즉, 다른 모듈의 코드 변경과 무관하게 core가 깨지는 순간 모든 모듈의 배포가 막힌다.

- 마찬가지로, admin 모듈 실패 → 전체 프로젝트 빌드 실패 → api 모듈은 정상이어도 배포할 수 없음.
- 즉, api 개발자 입장에서는  “내 모듈은 멀쩡한데 admin 때문에 배포가 막힌다” 라는 상황이 발생할 수 있음

**예시 : root 프로젝트 설정이 바뀌면서 오류 발생**
- 멀티모듈에서는 root 레벨에서 dependency 버전을 관리하는 경우가 많음:

```
#build.gradle
springBootVersion = 3.2.1  → 3.2.2 로 변경
```

- 이 변경으로:
  - admin은 잘 돌아감
  - api는 특정 dependency 충돌 발생 (예: JPA 이슈)
  - batch는 특정 bean 오류 발생

- 그런데 빌드는 보통 root 기준으로 실행(`./gradlew build`)
  - api 모듈에서 충돌 발생
  - 전체 빌드 실패
  - admin, batch 정상이어도 배포 불가

**그럼 CI를 모듈별로 나눠 빌드하면 되지않나 ?**
- CI를 모듈별로 나눠 빌드하면  admin 실패 때문에 api 배포가 막히는 문제는 줄어듦
- 하지만 여전히 다음 문제는 완전히 해결할 수 없음:
  - root-level 설정(gradle settings, root build.gradle) 변경 영향
  - core 같은 공통 모듈의 영향은 피할 수 없음
  - 모듈 간 코드·디펜던시 충돌은 빌드 모듈 구분과 관계 없음
  - 전체 레포 체크아웃 + 전체 그래프 로드 부담은 그대로
- 즉, “완전한 독립성”은 멀티모듈에서는 불가능

- 예를 들어: core에서 DTO 필드 삭제
→ admin은 빌드 성공 (이 필드 안 씀)
→ api는 빌드 실패 (이 필드 씀)

- 즉, admin CI는 통과할 수 있는데 api CI는 실패함.
- 이건 자연스럽지만, 문제는:
  - 멀티모듈에서는 한 레포 안에 있으므로 "팀 전체가" 동시 영향을 받음
- 독립 레포였다면:
  - core 버전 안 바꾸면 API는 지금까지의 core 1.0.0 사용
  - core 수정이 API를 바로 깨뜨리지 않음
  - 팀 간 CI 독립성이 훨씬 높음

**근데 이렇게되면 실수한걸 더 빠르게 인지할 수 있을 것 같아서 , 좋은 점도 있는 것 같은데**
- 장점1 : core 수정에 의한 API 영향 즉시 감지
  - core 수정 → API 컴파일 오류
  - 한 번의 빌드에서 바로 드러남
  - 릴리즈 직전에 깨지지 않음
  - 전체 시스템 간의 호환성이 유지됨

- 장점2 : 통합된 환경에서 전체 변경 영향 분석이 쉬움
  - 멀티모듈은 “하나의 도메인으로 움직이는 프로젝트”일 때 정말 편함.
  - 예:
    - core의 DTO 필드 변경
    - 여러 서비스가 그 DTO를 쓰고 있음 → root build에서 전부 확인 가능

- 장점3 : 코드 변경의 ripple effect를 빠르게 확인
  - 리팩토링 시 전체 모듈에 대한 영향 즉시 확인 가능
  - 대규모 구조 변경에 유리
  - 각 모듈 간 타입/계약 파괴 여부 자동 확인
  - 즉, 멀티모듈은 변화의 영향을 즉시 발견해서 개발 품질을 올린다. 이건 확실한 장점이에요.

- 단점1: 서비스가 독립적으로 배포되어야 하는데, 빌드/배포가 묶임
  - 현실적으로 API, Admin, Batch는 독립 서비스이고
  - 각각 다른 속도와 주기로 배포되어야 함.
  - 그런데 core 수정 하나가 API를 깨면:
    - API는 지금 배포하지 않아도 됨
    - Admin은 배포해야 함
    - Batch는 배포해야 함
  - 하지만 API 오류 때문에 전체 빌드 실패 → 전체 배포 STOP
  - 실무에선 이게 엄청난 리스크.

- 단점2: “더 빨리 발견”이라는 장점이, 팀 간 간섭으로 바뀜
  - 예시:
    - core 담당자가 필드 하나 삭제
    - API 팀 코드 깨짐
    - API 팀은 지금 개발 중인데, core 때문에 CI 깨짐
    - API 팀이 작업 중인 브랜치가 merge 못 함
    - 서로 blame / block 발생
  - 즉, 장점이 아니라 팀 간 충돌 요소가 됨.

- 단점3: 운영 서비스는 “빨리 깨지는 것”보다 “필요한 것만 배포하는 것”이 더 중요함
  - 좋은 설계 = 서비스별로 독립적으로:
    - 테스트
    - 배포
    - 스케일링
    - 롤백
  - 이 가능한 환경.
  - 멀티모듈은 즉시 빨리 깨지는 대신:
    - 배포 독립성 상실
    - 한 서비스의 CI 문제로 전체 배포 막힘
    - 불필요한 빌드 증가
    - 커플링 증가

### QnA 2 내 생각
- 배포 주기가 짧고, 배포가 빈번한 경우에는 멀티모듈 전체 빌드시, 특정 모듈로 인한 빌드 실패는 영향도가 클 수 있다고 생각
- 하지만, 배포 주기가 비교적 일정하고 프로젝트 전체의 안정성이 더 중요한 경우에는, 멀티모듈 구조를 통해 루트 모듈, core 모듈 등의 변경으로 인한 영향도를 빠르게 파악할 수 있는게 더 큰 이점이라고 생각

## QnA 3. 멀티모듈인 경우에도 서비스별 jar로 되니까, 각각 되는거아닌가
---
> 컨테이너 환경 각각 별도로 빌드/배포/롤백된다 ?? => 멀티모듈인 경우에도 서비스별 jar로 되니까, 각각 되는거아닌가 ?? 다만, 버전은 같이 올라가긴 하겠지만

## QnA. 빌드 속도와 Github Actions 비용 ?


