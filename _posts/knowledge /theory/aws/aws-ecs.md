
## AWS ECS (Elastic Container Service)
> 컨테이너 기반 애플리케이션을 손쉽게 배포하고 관리하며 확장할 수 있도록 도와주는 종합적인 **컨테이너 오케스트레이션 서비스**

### 특징
- AWS가 완전히 관리해 주는 서비스이기 때문에, 복잡한 컨트롤 플레인을 직접 설치하거나 운영할 필요가 없습니다.
- AWS가 권장하는 각종 설정·운영 모범사례(best practices) 를 기반에 깔고 있으며, Docker뿐만 아니라 Amazon Elastic Container Registry(ECR) 등 여러 AWS 서비스 및 외부 도구들과 자연스럽게 통합되어 있습니다.
- 덕분에 개발팀은 환경 구성이나 서버 운영에 시간을 쓰기보다는 애플리케이션 자체 개발 작업에 더 집중할 수 있습니다.
- 또한 ECS는 AWS 클라우드뿐 아니라 온프레미스 환경까지 포함해 전 세계 여러 리전에 걸쳐 컨테이너 워크로드를 실행하고 확장할 수 있습니다.
- 즉, ECS를 사용하면 복잡한 플랫폼 관리 없이도 컨테이너 기반 애플리케이션을 믿고 맡길 수 있다는 것이 핵심 포인트입니다.

### 핵심 포인트
**1. ECS는 Docker 기반의 서비스다**
- Docker는 일종의 가상화 기술을 기반으로 만들어진 “컨테이너” 기술로, 애플리케이션을 배포하는 과정을 훨씬 간단하게 만들어 줍니다.

**2. ECS는 Docker 이미지로 구동된다**
- Docker 이미지는 애플리케이션과 필요한 라이브러리·환경 설정을 그대로 묶은 스냅샷 같은 것으로, 이 이미지를 컨테이너나 ECS 같은 AWS 서비스 위에 손쉽게 배포할 수 있습니다.

**3. Fargate는 ECS와 특히 잘 어울리는 서버리스 서비스다**
- AWS Fargate는 ECS와 함께 자주 사용되는 서버리스 방식의 컨테이너 실행 서비스입니다.
- 여기서 "서버리스"라는 말은 정말로 서버가 없다는 뜻이 아니라, 사용자가 서버(EC2) 인프라를 직접 관리할 필요가 없어 보이도록 추상화했다는 의미입니다.
- 즉, 사용자는 “컨테이너를 실행한다”는 것만 생각하면 되는 구조입니다.

**4. ECS 클러스터 배포는 비교적 간단하다**
- ECS 클러스터를 배포하는 과정은 비교적 단순합니다.
- 클러스터를 만들 때 EC2 기반으로 할지, Fargate 기반으로 할지 등을 선택하고, 그 아래에서 실행될 서비스나 태스크 정의를 지정하는 식입니다.
- 특히 EC2 기반 ECS를 사용할 때는, 컨테이너가 실제로 실행될 EC2 인스턴스들도 함께 관리하게 됩니다.

## EC2 vs Fargate 선택
---
> ECS는 “컨테이너 오케스트레이션(관리) 서비스”이고
> EC2 / Fargate는 ECS가 컨테이너를 실행하기 위해 선택하는 “실행 방식(Runtime)”이다.

- ECS는 다음을 담당해:
  - 어떤 컨테이너를 몇 개 실행할지
  - 컨테이너가 죽으면 다시 띄우기
  - 이미지 버전 관리
  - 로드밸런서 연결
  - 서비스 상태 모니터링
- 즉 ECS는 컨테이너를 ‘어떻게 운영할지’를 결정하는 서비스야.
- 하지만, 실제 컨테이너 “실행”은 ECS가 직접 하는 것이 아님 ECS는 실행할 곳을 선택해야 함
- 그 실행 장소가 바로 EC2 또는 Fargate

### ECS on EC2
- 사용자가 직접 EC2 인스턴스를 만들고
- 클러스터를 구성하고
- 용량(CPU/RAM)을 관리하고
- OS 업데이트 등도 해야 함
- 즉, ECS가 컨테이너를 EC2 위에서 실행함 (사용자 = EC2 관리자 역할까지 해야 함)

### ECS on Fargate
- EC2 인스턴스 필요 없음
- AWS가 “컨테이너를 실행할 서버”를 대신 준비
- OS 패치, 용량 관리, AMI 관리 모두 AWS가 자동 처리
- 스케일링도 서버 없이 가능
- 즉, ECS는 “컨테이너 관리만” 하고 Fargate가 “컨테이너를 실행하는 서버 역할”을 대신함
- 운영 부담 거의 없음.
- 그래서 ECS + Fargate 조합이 보통 가장 관리 편하고 서버리스하게 사용할 수 있음.

## Docker 이해하기
---
> Docker는 애플리케이션을 효율적으로 가상화할 수 있는 방식을 제공
> 즉, 전통적 가상머신(Virtual Machine, VM) 방식을 쓰지 않는다.

### VM이란?
-  하나의 컴퓨터(호스트)의 자원을 일정 부분 “할당받아” **별도의 독립적인 시스템처럼 동작**하는 소프트웨어입니다.
- 즉, **호스트 컴퓨터의 하드웨어(CPU, RAM, GPU 등) 일부를 사용**해 완전히 별도의 OS와 애플리케이션을 실행하는 형태라고 보면 됩니다
- VM을 만들 수 있는 도구는 다양합니다. (VirtualBox, Parallels, VMware, Citrix, ...)

### Docker의 가상화 방식
> VM처럼 독립 운영체제 전체를 복제해 사용하지 않고, 호스트 운영체제의 핵심 요소를 직접(공유해서 ?) 활용

- VM
  - “운영체제를 통째로 하나 더 띄우는 방식”
  - “하드웨어를 가상화”하는 기술이라 무겁다. → OS 하나 띄우려면 메모리·CPU 등 자원을 많이 잡아먹음.
- Docker
  -  “**운영체제의 핵심 기능은 공유**하고, 필요한 부분만 따로 격리하는 방식”
  -  운영체제를 가상화(컨테이너화)”하는 기술이라 훨씬 가볍다. → OS 커널을 공유하기 때문에 메모리·CPU 사용량이 크게 줄어듦.
- 이러한 접근 방식 덕분에 Docker는 소프트웨어 배포 방식을 완전히 혁신했으며,
- 오늘날 대부분의 현대적인 애플리케이션 인프라에서 핵심 기술로 자리 잡게 되었습니다.

### 그림으로 비교

| 구분       | 전통적인 VM 방식                         | Docker 방식(컨테이너)                      |
| -------- | ---------------------------------- | ------------------------------------ |
| 실행 방식    | 하나의 호스트 위에 여러 VM을 실행               | 하나의 호스트 위에 다수의 컨테이너 실행               |
| 운영체제(OS) | **VM마다 독립된 OS 필요**                 | **호스트 OS의 커널을 공유함**                  |
| 구성 요소    | - VM마다 독립 OS<br>- OS 위에서 애플리케이션 실행 | - 컨테이너마다 애플리케이션만 포함<br>- OS를 중복하지 않음 |
| 자원 사용량   | **무거움 (OS 중복으로 자원 많이 소모)**         | **가벼움 (커널 공유로 자원 절약)**               |
| 확장성      | 제한적 — VM 수가 늘어날수록 메모리/CPU 부담 증가    | 매우 높음 — OS 복제 비용이 없으므로 많은 컨테이너 실행 가능 |
| 격리 수준    | 하드웨어 가상화 기반 강력한 격리                 | 프로세스 기반 격리(NS, cgroups)              |
| 요약       | OS를 매번 통째로 띄우는 구조                  | 필요한 앱 환경만 격리해서 띄우는 구조                |


### 컨테이너 ?
=> https://www.youtube.com/watch?v=zh0OMXg2Kog

- 프로세스마다 고유한 공간(메모리)를 OS로부터 할당받는다 => 가상메모리
- 가상메모리
  - (RAM + HDD)를 추상화
  - **프로세스마다 독립적인 공간** => 멀티태스킹 환경

**전통적인 VM 가상화 방식**
![img.png](img.png)

- Docker 탄생 배경 :결국 Guest OS를 사용하는 이유는 3,6의 프로세스(프로그램)을 사용하기 위함일텐데, (4,5,7,8)에 해당 하는 부분이 꼭 필요할까 ?
![img_1.png](img_1.png)

**Docker의 가상화 방식**
![img_2.png](img_2.png)

- 프로그램 실행을 위해 필요한 App, Bin / Library 추상화 (컨테이너)
- OS는 Container Runtime 통해 각각의 컨테이너와 연결 (마치, MS Word를 깔아놓고 여러번 실행할 수 있듯이, OS도 이미 설치되어 있는 프로그램)
- 도커 엔진이 컨테이너에서 필요한 OS 관련된 호출을 대신해주고 응답을 준다

- 이게 가능한 대전제 ?


### Docker 이미지
> 컨테이너에서 실행되는 애플리케이션들의 상태를 그대로 담아 둔 **스냅샷**

- 애플리케이션뿐 아니라 그 애플리케이션이 필요로 하는 모든 소프트웨어와 설정(Configuration)이 포함됩니다.
- Docker 엔진이 OS 레벨의 요구사항을 알아서 처리해 주기 때문에, 동일한 Docker 이미지는 Linux·Windows·macOS 등 어디에서나 동일하게 실행될 수 있다.
- 즉, OS에 따라 실행 환경을 다르게 설정할 필요 없이 “이미지 하나로 동일한 환경”을 그대로 재현할 수 있는 것입니다.

**1. Dockerfile 작성**
- Docker 이미지를 만들기 위한 첫 단계는 Dockerfile을 작성하는 것입니다.
  이 파일은 YAML과 비슷한 구조(정확히는 Dockerfile 문법)로 작성되며, 컨테이너를 구성하는 데 필요한 설정 정보와 실행 과정(Build instructions) 이 포함됩니다.
- 예: 어떤 베이스 이미지(ubuntu, alpine 등)를 사용할 것인지, 어떤 라이브러리를 설치할지, 어떤 파일을 복사할지 등.

**2. 이미지 빌드 → 레지스트리에 저장**
- 빌드된 Docker 이미지는 레지스트리(repository) 에 저장되었다가 필요할 때 다시 가져다(pull) 사용할 수 있습니다.
- 대표적인 레지스트리는 아래와 같습니다.

| 레지스트리                                    | 특징                                            |
| ---------------------------------------- | --------------------------------------------- |
| **Docker Hub**                           | 가장 널리 사용되는 Docker의 공식 레지스트리                   |
| **AWS ECR (Elastic Container Registry)** | AWS에서 제공하는 개인용/기업용 Docker 이미지 레지스트리, 자체 관리 가능 |


## Docker On AWS
---
> 현대 애플리케이션의 핵심 구성요소로 Docker가 자리 잡으면서, AWS 역시 컨테이너 기술을 활용하거나 확장할 수 있는 다양한 서비스를 제공합니다.
즉, AWS는 “Docker를 실행하고 관리하기 위한 여러 가지 옵션”을 가지고 있고, 각각의 서비스가 다른 방식으로 컨테이너를 지원합니다.

### AWS ECS
> Amazon ECS는 AWS가 제공하는 컨테이너 플랫폼으로,
사용자가 만든 **Docker 이미지를 EC2 인스턴스 위에 배포**하는 서비스

- ECS의 주요 역할은 다음과 같습니다:
  - Docker 컨테이너를 EC2 인스턴스에 배포
  - 컨테이너가 정상적으로 잘 동작하는지 모니터링
  - 컨테이너가 여러 인스턴스에 분산되도록 관리
  - 이미지 버전 업데이트나 재시작 같은 운영 작업 자동화

- 즉, ECS는 “Docker 컨테이너를 여러 EC2 서버 위에서 안정적으로 운영하려는 사용자” 를 위한 관리형 플랫폼

## QQQ
- 컨테이너 기반 애플리케이션 ?
- ECS가 ECR과 도커와 자연스럽게 통합 ?
- 또한 ECS는 AWS 클라우드뿐 아니라 온프레미스 환경까지 포함해 전 세계 여러 리전에 걸쳐 컨테이너 워크로드를 실행하고 확장할 수 있습니다. ?
- Fargate를 사용하면 EC2 인스턴스 없이 컨테이너만 실행할 수 있으며 ??
- VM처럼 독립 운영체제 전체를 복제해 사용하지 않고, 호스트 운영체제의 핵심 요소를 직접 활용??
- 컨테이너에서 실행되는 애플리케이션들의 상태를 그대로 담아 둔 스냅샷
  => 애플리케이션의 상태 ??

## 참고 자료
---
- https://www.kerno.io/blog/aws-ecs-docker-fargate-containers
