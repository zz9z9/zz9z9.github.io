---
title: 멀티모듈 구조 고민해보기
date: 2025-11-24 22:00:00 +0900
categories: [경험하기, 작업 노트]
tags: []
---

## 모듈 ?
---
> 독립적인 배포 / 실행 단위 ?
> core는 실행은 안되니까 .. 음 .. 뭐라고 표현하는게 적절할까

## 내가 경험했던 멀티모듈
---
> 나의 경우는 보통, 하나의 도메인을 공유하는 api / admin / batch 모듈이 있고, core에 도메인 관련 공통적인 코드나, 로직 등을 응집해놓는 역할로 사용

- 즉, 생각해보면:
  - 코드 중복 줄이고,
  - 재사용성 증가
- 정도의 이점을 누렸던 것 같다.

- 반면 단점은:
  - 굳이 core에 있지 않아도 될 코드들도 다 core로 들어오게 되는 경우가 많은 것 같음
    - 빌드시간 증가, 코드 파악하는데 시간이 더 걸림,
    - 특정 모듈에서만 사용하는게 적절한데 의도치않게 다른 모듈에서 사용하면 추후 변경시 영향 범위가 넓어짐 등
  - 불필요한 의존성이 늘어나게됨
    - ex : batch에서는 web이 굳이 필요 없을 수 있는데, core에 있으면 다 적용받음, db 커넥션이 불필요하게 많아질 수 있음


## 생각해보기
---

### 서비스를 위해 필요한 구성요소들

**애플리케이션**
- api 애플리케이션
- 어드민(운영)용 애플리케이션
- 사용자 서비스 애플리케이션
- 배치 애플리케이션
- 데이터 싱크 --> 요거 고민필요

**개발할때 필요한 구성요소들 생각해보기**
- 공통
  - 인프라 관련
    - DB
    - Kafka
    - Redis
  - Util 기능
  - 공통 비즈니스 로직 처리
  - 공통 응답 포맷
  - 공통 예외
  - 외부 호출 템플릿 ?
  - 로깅
  - 도메인 모델(엔티티) / VO

- 애플리케이션별
  - config => 커넥션풀에 세팅되는 커넥션 개수, 배치 설정 등등
  - end point
  - 요청/응답 포맷
  - 비즈니스 로직
  - 모듈 특화 예외
  - 특정 서비스 호출
  - 조회 전용 모델 등

### 멀티모듈 구조를 통해 얻을 수 있는 이점으로 재사용성 이외에 또 어떤것들이 있고, 단점은 어떻게 줄일 수 있을까 ?
**내가 생각하는 이점**
- 필요한 의존성만 추가함으로써, 불필요한 의존 코드로 인해 영향받는 일을 줄인다. (= 의존성 격리)
  - 예 : core에 jpa, mybatis 설정 다있으면 ? mybatis 관련 코드 수정 잘못됐는데, mybatis 사용하지도 않는 모듈에서 영향받음
  - `persistence-jpa`, `persistence-mybatis` 이런식으로 모듈 분리 가능할듯
- 의도치 않은 리소스 낭비 줄일수도 있음
  - 예 : jpa, mybatis 설정 다 core에 있으면, 둘 중 하나만 사용하는 모듈에서는 커넥션 풀 낭비한것

**이러한 이점을 취하려면, 어떤 기준으로 모듈 구조를 잡으면 좋을까 ?**
- 관심사가 비슷 == 특정 요구사항, 상황으로 인해 영향받을 가능성이 높은 코드들끼리 ?
  - 특정 요구사항이나 상황으로 인해, 변경되는 모듈이 최소화됨 == 영향받는 범위가 최소화됨
- 근데 jpa, mybatis 예로들면, 관심사라고 하긴 어려울것 같은데 ,, 음 ,, 기능 단위 ??

- 관심사(요구사항) ?
  - 도메인 => 도메인 요구사항 추가/변경으로 인한 코드 변경
    - 정책, 비즈니스 로직 ,, (수수료 1.0% => 1.1% ==> 비즈니스 로직보다는 정책에 가까운것 같은데,, 정책도 비즈니스 로직 안에 포함 ?)
  - 기능 구현
    => 도메인 로직 등을 활용하여, 해당 도메인의 목표 달성
    => 목표를 달성하기 위한 구현 방식 등이 달라질때(redis를 이용해서 조회 성능을 더 빠르게 ) 코드 변경
    => 도메인 요구사항 추가/변경으로 인한 코드 변경 (도메인 부분과 어떤 성격이 다를까 ?)
  - 인프라 => 인프라 변경, 설정 변경, 버전업, 특정 기능을 위한 인프라 의존성 추가 등으로 인한 코드 변경
  - 외부 연동 => 특정 PG사, 결제 시스템 등 ? => 결제도 여기서 다루는게 좋을까 ? => 외부 연동 시스템에 변경이 있을때 변경

| 관심사 | 정의                                                                | 코드 주요 변경 사유     | 예시 |
| ---- |-------------------------------------------------------------------|-----------------| --- |
| 도메인 | 도메인의 정체성(?)을 나타내는 핵심 코드들                                          | 도메인 요구사항 추가/변경 등 | 수수료 계산 방식이 달라짐   |
| 기능 구현 | 해당 도메인의 목표(ex : 정산 => 약속된 날짜에, 정확한 대상에게, 정확한 금액을 전달)를 달성하기 위한 코드들 | 구현 방식이 달라질 때,   |


핵심 비즈니스 로직: 시스템 없이도 존재하는 비즈니스 로직
유스케이스: 시스템이 있어야만 유효한 비즈니스 로직

**테스트 체계를 분리할 수 있다 — Test Isolation**
- 예:
  - persistence-jpa 모듈에서만 DB 통합 테스트
  - core는 순수 단위 테스트
  - web 모듈은 MVC Test만 돌림
  - 이렇게 하면 테스트 속도가 전체적으로 빨라짐.

```
multi-module-service
│
├── core                      ← 도메인 중심
│     ├── domain model
│     ├── domain service
│     ├── vo
│     └── common exception
│
├── infrastructure
│     ├── db-mysql
│     ├── persistence-jpa
│     ├── persistence-mybatis
│     ├── broker-kafka
│     └── cache-redis
│
├── api
├── batch
└── console-web
      ├── console-common          ← Filter, 보안, 공통 계층
      ├── master-console
      └── partner-console
```

=> 이런식이면 필요한 모듈에서 필요한 infra만 의존할 수 있다.
  => 즉 의존성 격리가 core만 사용할때보단 잘됨
  => 의도치 않은 리소스 낭비 줄일수도 있음 (jpa, mybatis 설정 다 core에 있으면, 둘 중 하나만 사용하는 모듈에서는 커넥션 풀 낭비한것)
  => 의존성이 잘 격리되면, 특정 코드를 변경할때 영향받는 코드(모듈)의 범위도 적절하게 제한된다는 것

=> jpa, mybatis 까지 나누고 싶으면 ??

=> 모듈
  => 변경되는 주기가 비슷한 코드들끼리 ?
  => 변경되는 모듈이 최소화됨 == 영향받는 모듈이 최소화됨
  => 변경되는 주기가 비슷 ? == 관심사가 비슷 == 특정 요구사항, 상황으로 인해 영향받을 가능성이 높은 코드들끼리 ?



### core의 역할을 어디까지로 정하는게 좋을까 ?
순수 비즈니스 규칙이라면 → core

예를 들어:

결제 재시도 정책

주문 상태 전이(READY → FAILED → RETRYABLE)

데이터 정합성 검증

특정 도메인 모델에 대한 계산 로직

보상 처리 정책

→ 이런 건 인프라 의존성이 없는 순수한 도메인 로직입니다.
→ Batch와 Admin 모두 동일하게 써야 하는 핵심 규칙

흐름(Flow)이나 애플리케이션 서비스 로직이라면 → 각 모듈에 존재해야 함

예:

관리자에서 재처리 버튼 누르면 실행되는 흐름

배치에서 스케줄 기반으로 호출되는 흐름

이건 각 모듈에 구현해야 하는 영역입니다.

아무리 같은 기능이라도 완전히 동일하게 동작하지는 않을 가능성이 매우 높기 때문입니다.

예를 들어:

Batch는 1,000건을 bulk 처리

Admin은 한 건만 재처리

실패 시 대응 방법이 다름

관리자 권한 체크 필요

즉, Flow/Application Layer는 재사용하면 안 됩니다.

## 실전 자료
---

### Case1
> https://engineering.linecorp.com/ko/blog/mono-repo-multi-project-gradle-plugin

### Case2
> https://www.youtube.com/watch?v=ipDzLJK-7Kc

- Bounded Context 기준으로 => 변화 주기 ?
![img_9.png](img_9.png)

### Case3
> https://www.youtube.com/watch?v=uvG-amw2u2s => https://mangkyu.tistory.com/304

**시스템에 독립적인 공통 코드 분리하기**
- 시스템에 독립적인 공통 코드라 함은 StringUtils나 DateUtils처럼 다른 어떤 시스템을 개발하더라도 사용될 수 있는 코드들을 의미
- 특정 시스템에 독립적인 코드들은 추후에 다른 프로젝트에서도 사용될 여지가 있기 때문에, 재사용성을 고려해 이를 기준으로 모듈을 분리하였다.
- 해당 모듈은 전역적으로 사용된다는 점, 그리고 대부분 유틸성 클래스라는 점에서 global-utils라고 이름을 지어주었다.
- 공통 모듈이라 하면 흔히 common 키워드를 떠올리는데, 여기서는 common이라는 네이밍을 사용하지 않았다.
  - 왜냐하면 common이라는 네이밍이 해당 모듈에 대한 접근 또는 인식을 가볍게 만들 수 있기 때문이다.

**서로 다른 수준(속도)의 공통코드 분리하기**
- 비즈니스와 관련된 도메인 영역은 비즈니스 요구 사항에 맞춰 수시로 변경된다.
- 반면에 데이터베이스 설정과 같은 인프라 영역은 특정 시점에 변경된다.
- 예를 들어 보안 취약점이 생겼다고 해서 혹은 사용중인 데이터베이스를 변경한다고 해서 비즈니스 부분이 바뀌어서는 안된다.
- 따라서 고수준 정책은 저수준 세부사항들로부터 분리될 필요가 있으며, 만약 분리되지 않는다면 데이터베이스를 바꾸는 등의 영향이 비즈니스 로직에 영향을 줄 수 있게 된다.
- 데이터베이스, 웹, 라이브러리, 프레임워크 등은 비즈니스가 아닌 영역들이며, 비즈니스와 다른 속도로 변한다. 즉, 이 둘은 변경이 요구되는 시점이 다르기 때문에 최대한 독립시켜주는 것이 좋다.

**서로 다른 기능의 모듈 분리하기**
- 우리가 담당하는 시스템은 서로 다른 기능들을 가질 수 있다.
- api를 제공해줄 수도 있고, 통계 또는 일괄 처리를 위해 배치 작업이 필요할 수도 있고, 관리자를 위해 SSR 기반의 웹페이지를 제공해줄 수도 있다.
- 이들은 서로 다른 기능의 모듈이고, 그에 따라 필요로 하는 의존성이 다르기 때문에 모듈로 나누어 주는 것이 좋다.

**서로 다른 액터의 모듈 분리하기**
- SRP는 “하나의 일만 해야한다”는 의미가 아니라 "단일 모듈은 변경의 이유가 하나, 오직 하나뿐 이여야 한다."는 것
- 여기서 변경의 이유가 하나여야 한다는 것은 하나의 액터만 책임져야 한다는 의미이며, 여기서 액터란 동일한 변경을 요청하는 사람들을 의미
- 즉, "하나의 모듈은 오직 하나의 액터에 대해서만 책임을 져야 한다."

![img_11.png](img_11.png)

![img_10.png](img_10.png)

- 새로운 요구사항이 들어오고 애플리케이션이 확장되면서 이러한 결정들은 수시로 재검토될 필요가 있다. 그래야만 시스템 아키텍처도 계속해서 진화하고, 더욱 복잡한 요구사항에 손쉽게 대응할 수 있다. 이렇듯 결정을 미뤄야 하는 이유는 어떤 구조가 더욱 적합한지 현재로써 판단하기 힘들기 때문이다.


### Case4
> https://techblog.woowahan.com/2637/
